<html>
 <head>
  <title>Espruino Reference</title>
  <style>
   body { font: 71%/1.5em  Verdana, 'Trebuchet MS', Arial, Sans-serif; color: #666666; }
   h1, h2, h3, h4 { color: #000000; margin-left: 0px; }
   h4 { padding-left: 20px; }
   .class { page-break-before: always; width:95%; border-top: 1px solid black; border-bottom: 1px solid black; padding-top: 20px; padding-bottom: 20px; margin-top: 50px; }
   .instance { font-weight: bold; }
   .detail { width:90%; border-bottom: 1px solid black; margin-top: 50px; }
   .top { float:right; }
   .call { padding-left: 50px; }
   .description { padding-left: 50px; }
   .param { padding-left: 50px; }
   .return { padding-left: 50px; }
  </style>
 </head>
 <body>
  <h1>Espruino Software Reference</h1>
  <p style="text-align:right;">Version 1v65</p>
  <h2><a name="contents">Contents</a></h2>
  <h3><a href="#_global">Globals</A></h3>
  <ul>
    <li><a href="#l__global_HIGH">variable HIGH</a></li>
    <li><a href="#l__global_Infinity">variable Infinity</a></li>
    <li><a href="#l__global_LOW">variable LOW</a></li>
    <li><a href="#l__global_NaN">variable NaN</a></li>
    <li><a href="#l__global_analogRead">function analogRead(pin)</a></li>
    <li><a href="#l__global_analogWrite">function analogWrite(pin,value,options)</a></li>
    <li><a href="#l__global_arguments">variable arguments</a></li>
    <li><a href="#l__global_atob">function atob(binaryData)</a></li>
    <li><a href="#l__global_btoa">function btoa(binaryData)</a></li>
    <li><a href="#l__global_changeInterval">function changeInterval(id,time)</a></li>
    <li><a href="#l__global_clearInterval">function clearInterval(id)</a></li>
    <li><a href="#l__global_clearTimeout">function clearTimeout(id)</a></li>
    <li><a href="#l__global_clearWatch">function clearWatch(id)</a></li>
    <li><a href="#l__global_digitalPulse">function digitalPulse(pin,value,time)</a></li>
    <li><a href="#l__global_digitalRead">function digitalRead(pin)</a></li>
    <li><a href="#l__global_digitalWrite">function digitalWrite(pin,value)</a></li>
    <li><a href="#l__global_dump">function dump()</a></li>
    <li><a href="#l__global_echo">function echo(echoOn)</a></li>
    <li><a href="#l__global_edit">function edit(funcName)</a></li>
    <li><a href="#l__global_eval">function eval(code)</a></li>
    <li><a href="#l__global_getPinMode">function getPinMode(pin)</a></li>
    <li><a href="#l__global_getSerial">function getSerial()</a></li>
    <li><a href="#l__global_getTime">function getTime()</a></li>
    <li><a href="#l__global_isNaN">function isNaN(x)</a></li>
    <li><a href="#l__global_load">function load()</a></li>
    <li><a href="#l__global_parseFloat">function parseFloat(string)</a></li>
    <li><a href="#l__global_parseInt">function parseInt(string,radix)</a></li>
    <li><a href="#l__global_peek16">function peek16(addr)</a></li>
    <li><a href="#l__global_peek32">function peek32(addr)</a></li>
    <li><a href="#l__global_peek8">function peek8(addr)</a></li>
    <li><a href="#l__global_pinMode">function pinMode(pin,mode)</a></li>
    <li><a href="#l__global_poke16">function poke16(addr,value)</a></li>
    <li><a href="#l__global_poke32">function poke32(addr,value)</a></li>
    <li><a href="#l__global_poke8">function poke8(addr,value)</a></li>
    <li><a href="#l__global_print">function print(text,...)</a></li>
    <li><a href="#l__global_require">function require(moduleName)</a></li>
    <li><a href="#l__global_reset">function reset()</a></li>
    <li><a href="#l__global_save">function save()</a></li>
    <li><a href="#l__global_setBusyIndicator">function setBusyIndicator(pin)</a></li>
    <li><a href="#l__global_setDeepSleep">function setDeepSleep(sleep)</a></li>
    <li><a href="#l__global_setInterval">function setInterval(function,timeout)</a></li>
    <li><a href="#l__global_setSleepIndicator">function setSleepIndicator(pin)</a></li>
    <li><a href="#l__global_setTimeout">function setTimeout(function,timeout)</a></li>
    <li><a href="#l__global_setWatch">function setWatch(function,pin,options)</a></li>
    <li><a href="#l__global_trace">function trace(root)</a></li>
  </ul>
   <h3><a href="#Array">Array</a></h3>
  <ul>
    <li><a href="#l_Array_Array">constructor Array(args,...)</a></li>
    <li><a href="#l_Array_concat">function Array.concat(args,...)</a></li>
    <li><a href="#l_Array_every">function Array.every(function,thisArg)</a></li>
    <li><a href="#l_Array_fill">function Array.fill(value,start,end)</a></li>
    <li><a href="#l_Array_filter">function Array.filter(function,thisArg)</a></li>
    <li><a href="#l_Array_forEach">function Array.forEach(function,thisArg)</a></li>
    <li><a href="#l_Array_indexOf">function Array.indexOf(value)</a></li>
    <li><a href="#l_Array_isArray">Array.isArray(var)</a></li>
    <li><a href="#l_Array_join">function Array.join(separator)</a></li>
    <li><a href="#l_Array_length">property Array.length</a></li>
    <li><a href="#l_Array_map">function Array.map(function,thisArg)</a></li>
    <li><a href="#l_Array_pop">function Array.pop()</a></li>
    <li><a href="#l_Array_push">function Array.push(arguments,...)</a></li>
    <li><a href="#l_Array_reduce">function Array.reduce(callback,initialValue)</a></li>
    <li><a href="#l_Array_shift">function Array.shift()</a></li>
    <li><a href="#l_Array_slice">function Array.slice(start,end)</a></li>
    <li><a href="#l_Array_some">function Array.some(function,thisArg)</a></li>
    <li><a href="#l_Array_sort">function Array.sort(var)</a></li>
    <li><a href="#l_Array_splice">function Array.splice(index,howMany,elements,...)</a></li>
    <li><a href="#l_Array_toString">function Array.toString(radix)</a></li>
    <li><a href="#l_Array_unshift">function Array.unshift(elements,...)</a></li>
  </ul>
   <h3><a href="#ArrayBuffer">ArrayBuffer</a></h3>
  <ul>
    <li><a href="#l_ArrayBuffer_ArrayBuffer">constructor ArrayBuffer(byteLength)</a></li>
  </ul>
   <h3><a href="#ArrayBufferView">ArrayBufferView</a></h3>
  <ul>
    <li><a href="#l_ArrayBufferView_buffer">property ArrayBufferView.buffer</a></li>
    <li><a href="#l_ArrayBufferView_byteLength">property ArrayBufferView.byteLength</a></li>
    <li><a href="#l_ArrayBufferView_byteOffset">property ArrayBufferView.byteOffset</a></li>
    <li><a href="#l_ArrayBufferView_fill">function ArrayBufferView.fill(value,start,end)</a></li>
    <li><a href="#l_ArrayBufferView_forEach">function ArrayBufferView.forEach(function,thisArg)</a></li>
    <li><a href="#l_ArrayBufferView_indexOf">function ArrayBufferView.indexOf(value)</a></li>
    <li><a href="#l_ArrayBufferView_join">function ArrayBufferView.join(separator)</a></li>
    <li><a href="#l_ArrayBufferView_map">function ArrayBufferView.map(function,thisArg)</a></li>
    <li><a href="#l_ArrayBufferView_reduce">function ArrayBufferView.reduce(callback,initialValue)</a></li>
    <li><a href="#l_ArrayBufferView_set">function ArrayBufferView.set(arr,offset)</a></li>
    <li><a href="#l_ArrayBufferView_sort">function ArrayBufferView.sort(var)</a></li>
  </ul>
   <h3><a href="#CC3000">CC3000</a></h3>
  <ul>
    <li><a href="#l_CC3000_connect">CC3000.connect()</a></li>
  </ul>
   <h3><a href="#Double">Double</a></h3>
  <ul>
    <li><a href="#l_Double_doubleToIntBits">Double.doubleToIntBits(x)</a></li>
  </ul>
   <h3><a href="#E">E</a></h3>
  <ul>
    <li><a href="#l_E_FFT">E.FFT(arrReal,arrImage,inverse)</a></li>
    <li><a href="#l_E_clip">E.clip(x,min,max)</a></li>
    <li><a href="#l_E_convolve">E.convolve(arr1,arr2,offset)</a></li>
    <li><a href="#l_E_enableWatchdog">E.enableWatchdog(timeout)</a></li>
    <li><a href="#l_E_getAnalogVRef">E.getAnalogVRef()</a></li>
    <li><a href="#l_E_getTemperature">E.getTemperature()</a></li>
    <li><a href="#l_E_interpolate">E.interpolate(array,index)</a></li>
    <li><a href="#l_E_interpolate2d">E.interpolate2d(array,width,x,y)</a></li>
    <li><a href="#l_E_nativeCall">E.nativeCall(addr,sig)</a></li>
    <li><a href="#l_E_openFile">E.openFile(path,mode)</a></li>
    <li><a href="#l_E_reverseByte">E.reverseByte(x)</a></li>
    <li><a href="#l_E_sum">E.sum(arr)</a></li>
    <li><a href="#l_E_toArrayBuffer">E.toArrayBuffer(str)</a></li>
    <li><a href="#l_E_variance">E.variance(arr,mean)</a></li>
  </ul>
   <h3><a href="#Ethernet">Ethernet</a></h3>
  <ul>
    <li><a href="#l_Ethernet_getIP">function Ethernet.getIP()</a></li>
    <li><a href="#l_Ethernet_setIP">function Ethernet.setIP(options)</a></li>
  </ul>
   <h3><a href="#File">File</a></h3>
  <ul>
    <li><a href="#l_File_close">function File.close()</a></li>
    <li><a href="#l_File_pipe">function File.pipe(destination,options)</a></li>
    <li><a href="#l_File_read">function File.read(length)</a></li>
    <li><a href="#l_File_skip">function File.skip(nBytes)</a></li>
    <li><a href="#l_File_write">function File.write(buffer)</a></li>
  </ul>
   <h3><a href="#Float32Array">Float32Array</a></h3>
  <ul>
    <li><a href="#l_Float32Array_Float32Array">constructor Float32Array(arr,byteOffset,length)</a></li>
  </ul>
   <h3><a href="#Float64Array">Float64Array</a></h3>
  <ul>
    <li><a href="#l_Float64Array_Float64Array">constructor Float64Array(arr,byteOffset,length)</a></li>
  </ul>
   <h3><a href="#Function">Function</a></h3>
  <ul>
    <li><a href="#l_Function_apply">function Function.apply(this,args)</a></li>
    <li><a href="#l_Function_call">function Function.call(this,params,...)</a></li>
    <li><a href="#l_Function_replaceWith">function Function.replaceWith(newFunc)</a></li>
  </ul>
   <h3><a href="#Graphics">Graphics</a></h3>
  <ul>
    <li><a href="#l_Graphics_clear">function Graphics.clear()</a></li>
    <li><a href="#l_Graphics_createArrayBuffer">Graphics.createArrayBuffer(width,height,bpp,options)</a></li>
    <li><a href="#l_Graphics_createCallback">Graphics.createCallback(width,height,bpp,callback)</a></li>
    <li><a href="#l_Graphics_createSDL">Graphics.createSDL(width,height)</a></li>
    <li><a href="#l_Graphics_drawImage">function Graphics.drawImage(image,x,y)</a></li>
    <li><a href="#l_Graphics_drawLine">function Graphics.drawLine(x1,y1,x2,y2)</a></li>
    <li><a href="#l_Graphics_drawRect">function Graphics.drawRect(x1,y1,x2,y2)</a></li>
    <li><a href="#l_Graphics_drawString">function Graphics.drawString(str,x,y)</a></li>
    <li><a href="#l_Graphics_fillPoly">function Graphics.fillPoly(poly)</a></li>
    <li><a href="#l_Graphics_fillRect">function Graphics.fillRect(x1,y1,x2,y2)</a></li>
    <li><a href="#l_Graphics_getBgColor">function Graphics.getBgColor()</a></li>
    <li><a href="#l_Graphics_getColor">function Graphics.getColor()</a></li>
    <li><a href="#l_Graphics_getHeight">function Graphics.getHeight()</a></li>
    <li><a href="#l_Graphics_getPixel">function Graphics.getPixel(x,y)</a></li>
    <li><a href="#l_Graphics_getWidth">function Graphics.getWidth()</a></li>
    <li><a href="#l_Graphics_lineTo">function Graphics.lineTo(x,y)</a></li>
    <li><a href="#l_Graphics_moveTo">function Graphics.moveTo(x,y)</a></li>
    <li><a href="#l_Graphics_setBgColor">function Graphics.setBgColor(r,g,b)</a></li>
    <li><a href="#l_Graphics_setColor">function Graphics.setColor(r,g,b)</a></li>
    <li><a href="#l_Graphics_setFontBitmap">function Graphics.setFontBitmap()</a></li>
    <li><a href="#l_Graphics_setFontCustom">function Graphics.setFontCustom(bitmap,firstChar,width,height)</a></li>
    <li><a href="#l_Graphics_setFontVector">function Graphics.setFontVector(size)</a></li>
    <li><a href="#l_Graphics_setPixel">function Graphics.setPixel(x,y,col)</a></li>
    <li><a href="#l_Graphics_setRotation">function Graphics.setRotation(rotation,reflect)</a></li>
    <li><a href="#l_Graphics_stringWidth">function Graphics.stringWidth(str)</a></li>
  </ul>
   <h3><a href="#Hardware">Hardware</a></h3>
  <ul>
  </ul>
   <h3><a href="#I2C">I2C</a></h3>
  <ul>
    <li><a href="#l_I2C_readFrom">function I2C.readFrom(address,quantity)</a></li>
    <li><a href="#l_I2C_setup">function I2C.setup(options)</a></li>
    <li><a href="#l_I2C_writeTo">function I2C.writeTo(address,data,...)</a></li>
  </ul>
   <h3><a href="#Int16Array">Int16Array</a></h3>
  <ul>
    <li><a href="#l_Int16Array_Int16Array">constructor Int16Array(arr,byteOffset,length)</a></li>
  </ul>
   <h3><a href="#Int32Array">Int32Array</a></h3>
  <ul>
    <li><a href="#l_Int32Array_Int32Array">constructor Int32Array(arr,byteOffset,length)</a></li>
  </ul>
   <h3><a href="#Int8Array">Int8Array</a></h3>
  <ul>
    <li><a href="#l_Int8Array_Int8Array">constructor Int8Array(arr,byteOffset,length)</a></li>
  </ul>
   <h3><a href="#Integer">Integer</a></h3>
  <ul>
  </ul>
   <h3><a href="#JSON">JSON</a></h3>
  <ul>
    <li><a href="#l_JSON_parse">JSON.parse(string)</a></li>
    <li><a href="#l_JSON_stringify">JSON.stringify(data)</a></li>
  </ul>
   <h3><a href="#Math">Math</a></h3>
  <ul>
    <li><a href="#l_Math_E">Math.E</a></li>
    <li><a href="#l_Math_LN10">Math.LN10</a></li>
    <li><a href="#l_Math_LN2">Math.LN2</a></li>
    <li><a href="#l_Math_LOG10E">Math.LOG10E</a></li>
    <li><a href="#l_Math_LOG2E">Math.LOG2E</a></li>
    <li><a href="#l_Math_PI">Math.PI</a></li>
    <li><a href="#l_Math_SQRT1_2">Math.SQRT1_2</a></li>
    <li><a href="#l_Math_SQRT2">Math.SQRT2</a></li>
    <li><a href="#l_Math_abs">Math.abs(x)</a></li>
    <li><a href="#l_Math_acos">Math.acos(x)</a></li>
    <li><a href="#l_Math_asin">Math.asin(x)</a></li>
    <li><a href="#l_Math_atan">Math.atan(x)</a></li>
    <li><a href="#l_Math_atan2">Math.atan2(y,x)</a></li>
    <li><a href="#l_Math_ceil">Math.ceil(x)</a></li>
    <li><a href="#l_Math_clip">Math.clip(x,min,max)</a></li>
    <li><a href="#l_Math_cos">Math.cos(theta)</a></li>
    <li><a href="#l_Math_exp">Math.exp(x)</a></li>
    <li><a href="#l_Math_floor">Math.floor(x)</a></li>
    <li><a href="#l_Math_log">Math.log(x)</a></li>
    <li><a href="#l_Math_max">Math.max(args,...)</a></li>
    <li><a href="#l_Math_min">Math.min(args,...)</a></li>
    <li><a href="#l_Math_pow">Math.pow(x,y)</a></li>
    <li><a href="#l_Math_random">Math.random()</a></li>
    <li><a href="#l_Math_round">Math.round(x)</a></li>
    <li><a href="#l_Math_sin">Math.sin(theta)</a></li>
    <li><a href="#l_Math_sqrt">Math.sqrt(x)</a></li>
    <li><a href="#l_Math_tan">Math.tan(theta)</a></li>
    <li><a href="#l_Math_wrap">Math.wrap(x,max)</a></li>
  </ul>
   <h3><a href="#Modules">Modules</a></h3>
  <ul>
    <li><a href="#l_Modules_addCached">Modules.addCached(id,sourcecode)</a></li>
    <li><a href="#l_Modules_getCached">Modules.getCached()</a></li>
    <li><a href="#l_Modules_removeAllCached">Modules.removeAllCached()</a></li>
    <li><a href="#l_Modules_removeCached">Modules.removeCached(id)</a></li>
  </ul>
   <h3><a href="#Number">Number</a></h3>
  <ul>
    <li><a href="#l_Number_MAX_VALUE">Number.MAX_VALUE</a></li>
    <li><a href="#l_Number_MIN_VALUE">Number.MIN_VALUE</a></li>
    <li><a href="#l_Number_NEGATIVE_INFINITY">Number.NEGATIVE_INFINITY</a></li>
    <li><a href="#l_Number_NaN">Number.NaN</a></li>
    <li><a href="#l_Number_Number">constructor Number(value)</a></li>
    <li><a href="#l_Number_POSITIVE_INFINITY">Number.POSITIVE_INFINITY</a></li>
    <li><a href="#l_Number_toFixed">function Number.toFixed(decimalPlaces)</a></li>
  </ul>
   <h3><a href="#Object">Object</a></h3>
  <ul>
    <li><a href="#l_Object_clone">function Object.clone()</a></li>
    <li><a href="#l_Object_emit">function Object.emit(event,args,...)</a></li>
    <li><a href="#l_Object_getOwnPropertyNames">Object.getOwnPropertyNames(object)</a></li>
    <li><a href="#l_Object_hasOwnProperty">function Object.hasOwnProperty(name)</a></li>
    <li><a href="#l_Object_keys">Object.keys(object)</a></li>
    <li><a href="#l_Object_length">property Object.length</a></li>
    <li><a href="#l_Object_on">function Object.on(event,listener)</a></li>
    <li><a href="#l_Object_removeAllListeners">function Object.removeAllListeners(event)</a></li>
    <li><a href="#l_Object_toString">function Object.toString(radix)</a></li>
    <li><a href="#l_Object_valueOf">function Object.valueOf()</a></li>
  </ul>
   <h3><a href="#OneWire">OneWire</a></h3>
  <ul>
    <li><a href="#l_OneWire_OneWire">constructor OneWire(pin)</a></li>
    <li><a href="#l_OneWire_read">function OneWire.read()</a></li>
    <li><a href="#l_OneWire_reset">function OneWire.reset()</a></li>
    <li><a href="#l_OneWire_search">function OneWire.search()</a></li>
    <li><a href="#l_OneWire_select">function OneWire.select(rom)</a></li>
    <li><a href="#l_OneWire_skip">function OneWire.skip()</a></li>
    <li><a href="#l_OneWire_write">function OneWire.write(data,power)</a></li>
  </ul>
   <h3><a href="#Pin">Pin</a></h3>
  <ul>
    <li><a href="#l_Pin_Pin">constructor Pin(value)</a></li>
    <li><a href="#l_Pin_read">function Pin.read()</a></li>
    <li><a href="#l_Pin_reset">function Pin.reset()</a></li>
    <li><a href="#l_Pin_set">function Pin.set()</a></li>
    <li><a href="#l_Pin_write">function Pin.write(value)</a></li>
    <li><a href="#l_Pin_writeAtTime">function Pin.writeAtTime(value,time)</a></li>
  </ul>
   <h3><a href="#Pipe">Pipe</a></h3>
  <ul>
  </ul>
   <h3><a href="#SPI">SPI</a></h3>
  <ul>
    <li><a href="#l_SPI_SPI">constructor SPI()</a></li>
    <li><a href="#l_SPI_send">function SPI.send(data,nss_pin)</a></li>
    <li><a href="#l_SPI_send4bit">function SPI.send4bit(data,bit0,bit1,nss_pin)</a></li>
    <li><a href="#l_SPI_send8bit">function SPI.send8bit(data,bit0,bit1,nss_pin)</a></li>
    <li><a href="#l_SPI_setup">function SPI.setup(options)</a></li>
    <li><a href="#l_SPI_write">function SPI.write(data,...)</a></li>
  </ul>
   <h3><a href="#Serial">Serial</a></h3>
  <ul>
    <li><a href="#l_Serial_onData">function Serial.onData(function)</a></li>
    <li><a href="#l_Serial_print">function Serial.print(string)</a></li>
    <li><a href="#l_Serial_println">function Serial.println(string)</a></li>
    <li><a href="#l_Serial_setConsole">function Serial.setConsole()</a></li>
    <li><a href="#l_Serial_setup">function Serial.setup(baudrate,options)</a></li>
    <li><a href="#l_Serial_write">function Serial.write(data,...)</a></li>
  </ul>
   <h3><a href="#String">String</a></h3>
  <ul>
    <li><a href="#l_String_String">constructor String(str)</a></li>
    <li><a href="#l_String_charAt">function String.charAt(pos)</a></li>
    <li><a href="#l_String_charCodeAt">function String.charCodeAt(pos)</a></li>
    <li><a href="#l_String_fromCharCode">String.fromCharCode(code,...)</a></li>
    <li><a href="#l_String_indexOf">function String.indexOf(substring,fromIndex)</a></li>
    <li><a href="#l_String_lastIndexOf">function String.lastIndexOf(substring,fromIndex)</a></li>
    <li><a href="#l_String_length">property String.length</a></li>
    <li><a href="#l_String_replace">function String.replace(subStr,newSubStr)</a></li>
    <li><a href="#l_String_slice">function String.slice(start,end)</a></li>
    <li><a href="#l_String_split">function String.split(separator)</a></li>
    <li><a href="#l_String_substr">function String.substr(start,len)</a></li>
    <li><a href="#l_String_substring">function String.substring(start,end)</a></li>
    <li><a href="#l_String_toLowerCase">function String.toLowerCase()</a></li>
    <li><a href="#l_String_toUpperCase">function String.toUpperCase()</a></li>
  </ul>
   <h3><a href="#Trig">Trig</a></h3>
  <ul>
    <li><a href="#l_Trig_getErrorArray">Trig.getErrorArray()</a></li>
    <li><a href="#l_Trig_getErrors">Trig.getErrors()</a></li>
    <li><a href="#l_Trig_getPosAtTime">Trig.getPosAtTime(time)</a></li>
    <li><a href="#l_Trig_getRPM">Trig.getRPM()</a></li>
    <li><a href="#l_Trig_getTrigger">Trig.getTrigger(num)</a></li>
    <li><a href="#l_Trig_killTrigger">Trig.killTrigger(num)</a></li>
    <li><a href="#l_Trig_setTrigger">Trig.setTrigger(num,pos,pins,pulseLength)</a></li>
    <li><a href="#l_Trig_setup">Trig.setup(pin,options)</a></li>
  </ul>
   <h3><a href="#Uint16Array">Uint16Array</a></h3>
  <ul>
    <li><a href="#l_Uint16Array_Uint16Array">constructor Uint16Array(arr,byteOffset,length)</a></li>
  </ul>
   <h3><a href="#Uint32Array">Uint32Array</a></h3>
  <ul>
    <li><a href="#l_Uint32Array_Uint32Array">constructor Uint32Array(arr,byteOffset,length)</a></li>
  </ul>
   <h3><a href="#Uint8Array">Uint8Array</a></h3>
  <ul>
    <li><a href="#l_Uint8Array_Uint8Array">constructor Uint8Array(arr,byteOffset,length)</a></li>
  </ul>
   <h3><a href="#WIZnet">WIZnet</a></h3>
  <ul>
    <li><a href="#l_WIZnet_connect">WIZnet.connect()</a></li>
  </ul>
   <h3><a href="#WLAN">WLAN</a></h3>
  <ul>
    <li><a href="#l_WLAN_connect">function WLAN.connect(ap,key,callback)</a></li>
    <li><a href="#l_WLAN_disconnect">function WLAN.disconnect()</a></li>
    <li><a href="#l_WLAN_getIP">function WLAN.getIP()</a></li>
    <li><a href="#l_WLAN_reconnect">function WLAN.reconnect()</a></li>
    <li><a href="#l_WLAN_setIP">function WLAN.setIP(options)</a></li>
  </ul>
   <h3><a href="#Waveform">Waveform</a></h3>
  <ul>
    <li><a href="#l_Waveform_Waveform">constructor Waveform(samples,options)</a></li>
    <li><a href="#l_Waveform_startInput">function Waveform.startInput(output,freq,options)</a></li>
    <li><a href="#l_Waveform_startOutput">function Waveform.startOutput(output,freq,options)</a></li>
    <li><a href="#l_Waveform_stop">function Waveform.stop()</a></li>
  </ul>
   <h3><a href="#console">console</a></h3>
  <ul>
    <li><a href="#l_console_log">console.log(text,...)</a></li>
  </ul>
   <h3><a href="#fs">fs</a></h3>
  <ul>
    <li><a href="#l_fs_appendFile">fs.appendFile(path,data)</a></li>
    <li><a href="#l_fs_appendFileSync">fs.appendFileSync(path,data)</a></li>
    <li><a href="#l_fs_pipe">fs.pipe(source,destination,options)</a></li>
    <li><a href="#l_fs_readFile">fs.readFile(path)</a></li>
    <li><a href="#l_fs_readFileSync">fs.readFileSync(path)</a></li>
    <li><a href="#l_fs_readdir">fs.readdir(path)</a></li>
    <li><a href="#l_fs_readdirSync">fs.readdirSync(path)</a></li>
    <li><a href="#l_fs_unlink">fs.unlink(path)</a></li>
    <li><a href="#l_fs_unlinkSync">fs.unlinkSync(path)</a></li>
    <li><a href="#l_fs_writeFile">fs.writeFile(path,data)</a></li>
    <li><a href="#l_fs_writeFileSync">fs.writeFileSync(path,data)</a></li>
  </ul>
   <h3><a href="#http">http</a></h3>
  <ul>
    <li><a href="#l_http_createServer">http.createServer(callback)</a></li>
    <li><a href="#l_http_get">http.get(options,callback)</a></li>
    <li><a href="#l_http_request">http.request(options,callback)</a></li>
  </ul>
   <h3><a href="#httpCRq">httpCRq</a></h3>
  <ul>
    <li><a href="#l_httpCRq_end">function httpCRq.end(data)</a></li>
    <li><a href="#l_httpCRq_write">function httpCRq.write(data)</a></li>
  </ul>
   <h3><a href="#httpCRs">httpCRs</a></h3>
  <ul>
  </ul>
   <h3><a href="#httpSRq">httpSRq</a></h3>
  <ul>
  </ul>
   <h3><a href="#httpSRs">httpSRs</a></h3>
  <ul>
    <li><a href="#l_httpSRs_end">function httpSRs.end(data)</a></li>
    <li><a href="#l_httpSRs_write">function httpSRs.write(data)</a></li>
    <li><a href="#l_httpSRs_writeHead">function httpSRs.writeHead(statusCode,headers)</a></li>
  </ul>
   <h3><a href="#httpSrv">httpSrv</a></h3>
  <ul>
    <li><a href="#l_httpSrv_close">function httpSrv.close()</a></li>
    <li><a href="#l_httpSrv_listen">function httpSrv.listen(port)</a></li>
  </ul>
   <h3><a href="#process">process</a></h3>
  <ul>
    <li><a href="#l_process_env">process.env</a></li>
    <li><a href="#l_process_memory">process.memory()</a></li>
    <li><a href="#l_process_version">process.version</a></li>
  </ul>
   <h3><a href="#url">url</a></h3>
  <ul>
    <li><a href="#l_url_parse">url.parse(urlStr,parseQuery)</a></li>
  </ul>
  <h2>Detail</h2>
<h2 class="class"><a name="_global">Global Functions</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l__global_HIGH">variable HIGH</a></li>
    <li><a href="#l__global_Infinity">variable Infinity</a></li>
    <li><a href="#l__global_LOW">variable LOW</a></li>
    <li><a href="#l__global_NaN">variable NaN</a></li>
    <li><a href="#l__global_analogRead">function analogRead(pin)</a></li>
    <li><a href="#l__global_analogWrite">function analogWrite(pin,value,options)</a></li>
    <li><a href="#l__global_arguments">variable arguments</a></li>
    <li><a href="#l__global_atob">function atob(binaryData)</a></li>
    <li><a href="#l__global_btoa">function btoa(binaryData)</a></li>
    <li><a href="#l__global_changeInterval">function changeInterval(id,time)</a></li>
    <li><a href="#l__global_clearInterval">function clearInterval(id)</a></li>
    <li><a href="#l__global_clearTimeout">function clearTimeout(id)</a></li>
    <li><a href="#l__global_clearWatch">function clearWatch(id)</a></li>
    <li><a href="#l__global_digitalPulse">function digitalPulse(pin,value,time)</a></li>
    <li><a href="#l__global_digitalRead">function digitalRead(pin)</a></li>
    <li><a href="#l__global_digitalWrite">function digitalWrite(pin,value)</a></li>
    <li><a href="#l__global_dump">function dump()</a></li>
    <li><a href="#l__global_echo">function echo(echoOn)</a></li>
    <li><a href="#l__global_edit">function edit(funcName)</a></li>
    <li><a href="#l__global_eval">function eval(code)</a></li>
    <li><a href="#l__global_getPinMode">function getPinMode(pin)</a></li>
    <li><a href="#l__global_getSerial">function getSerial()</a></li>
    <li><a href="#l__global_getTime">function getTime()</a></li>
    <li><a href="#l__global_isNaN">function isNaN(x)</a></li>
    <li><a href="#l__global_load">function load()</a></li>
    <li><a href="#l__global_parseFloat">function parseFloat(string)</a></li>
    <li><a href="#l__global_parseInt">function parseInt(string,radix)</a></li>
    <li><a href="#l__global_peek16">function peek16(addr)</a></li>
    <li><a href="#l__global_peek32">function peek32(addr)</a></li>
    <li><a href="#l__global_peek8">function peek8(addr)</a></li>
    <li><a href="#l__global_pinMode">function pinMode(pin,mode)</a></li>
    <li><a href="#l__global_poke16">function poke16(addr,value)</a></li>
    <li><a href="#l__global_poke32">function poke32(addr,value)</a></li>
    <li><a href="#l__global_poke8">function poke8(addr,value)</a></li>
    <li><a href="#l__global_print">function print(text,...)</a></li>
    <li><a href="#l__global_require">function require(moduleName)</a></li>
    <li><a href="#l__global_reset">function reset()</a></li>
    <li><a href="#l__global_save">function save()</a></li>
    <li><a href="#l__global_setBusyIndicator">function setBusyIndicator(pin)</a></li>
    <li><a href="#l__global_setDeepSleep">function setDeepSleep(sleep)</a></li>
    <li><a href="#l__global_setInterval">function setInterval(function,timeout)</a></li>
    <li><a href="#l__global_setSleepIndicator">function setSleepIndicator(pin)</a></li>
    <li><a href="#l__global_setTimeout">function setTimeout(function,timeout)</a></li>
    <li><a href="#l__global_setWatch">function setWatch(function,pin,options)</a></li>
    <li><a href="#l__global_trace">function trace(root)</a></li>
  </ul>
  <h3 class="detail"><a name="l__global_HIGH">variable HIGH</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>variable HIGH</code></p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">Logic 1 for Arduino compatibility - this is the same as just typing <code>1</code></p>
  <h3 class="detail"><a name="l__global_Infinity">variable Infinity</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>variable Infinity</code></p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">Positive Infinity (1/0)</p>
  <h3 class="detail"><a name="l__global_LOW">variable LOW</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>variable LOW</code></p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">Logic 0 for Arduino compatibility - this is the same as just typing <code>0</code></p>
  <h3 class="detail"><a name="l__global_NaN">variable NaN</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>variable NaN</code></p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">Not a  Number</p>
  <h3 class="detail"><a name="l__global_analogRead">function analogRead</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function analogRead(pin)</code></p>
  <h4>Description</h4>
   <p class="description">Get the analog value of the given pin</p>
   <p class="description">This is different to Arduino which only returns an integer between 0 and 1023</p>
   <p class="description">However only pins connected to an ADC will work (see the datasheet)</p>
  <h4>Parameters</h4>
   <p class="param"><b> pin</b> The pin to use<br/>You can find out which pins to use by looking at <a href="#boards">your board's reference page</a> and searching for pins with the <code>ADC</code> markers.</p>
  <h4>Returns</h4>
   <p class="return">The analog Value of the Pin between 0 and 1</p>
  <h3 class="detail"><a name="l__global_analogWrite">function analogWrite</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function analogWrite(pin,value,options)</code></p>
  <h4>Description</h4>
   <p class="description">Set the analog Value of a pin. It will be output using PWM</p>
  <h4>Parameters</h4>
   <p class="param"><b> pin</b> The pin to use<br/>You can find out which pins to use by looking at <a href="#boards">your board's reference page</a> and searching for pins with the <code>PWM</code> or <code>DAC</code> markers.</p>
   <p class="param"><b> value</b> A value between 0 and 1</p>
   <p class="param"><b> options</b> An object containing options.<br/>Currently only freq (pulse frequency in Hz) is available: <code>analogWrite(A0,0.5,{ freq : 10 });</code> <br/>Note that specifying a frequency will force PWM output, even if the pin has a DAC</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_arguments">variable arguments</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>variable arguments</code></p>
  <h4>Description</h4>
   <p class="description">A variable containing the arguments given to the function</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">An array containing all the arguments given to the function</p>
  <h3 class="detail"><a name="l__global_atob">function atob</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function atob(binaryData)</code></p>
  <h4>Description</h4>
   <p class="description">Convert the supplied base64 string into a base64 string</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> binaryData</b> A string of base64 data to decode</p>
  <h4>Returns</h4>
   <p class="return">A string containing the decoded data</p>
  <h3 class="detail"><a name="l__global_btoa">function btoa</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function btoa(binaryData)</code></p>
  <h4>Description</h4>
   <p class="description">Convert the supplied string (or array) into a base64 string</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> binaryData</b> A string of data to encode</p>
  <h4>Returns</h4>
   <p class="return">A base64 encoded string</p>
  <h3 class="detail"><a name="l__global_changeInterval">function changeInterval</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function changeInterval(id,time)</code></p>
  <h4>Description</h4>
   <p class="description">Change the Interval on a callback created with setInterval, for example:</p>
   <p class="description"><code>var id = <a href="#l__global_setInterval">setInterval</a>(function () { <a href="#l__global_print">print</a>('foo'); }, 1000); // every second</code></p>
   <p class="description"><code>changeInterval(id, 1500); // now runs every 1.5 seconds</code></p>
   <p class="description">This takes effect the text time the callback is called (so it is not immediate).</p>
  <h4>Parameters</h4>
   <p class="param"><b> id</b> The id returned by a previous call to setInterval</p>
   <p class="param"><b> time</b> The new time period in ms</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_clearInterval">function clearInterval</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function clearInterval(id)</code></p>
  <h4>Description</h4>
   <p class="description">Clear the Interval that was created with setInterval, for example:</p>
   <p class="description"><code>var id = <a href="#l__global_setInterval">setInterval</a>(function () { <a href="#l__global_print">print</a>('foo'); }, 1000);</code></p>
   <p class="description"><code>clearInterval(id);</code></p>
   <p class="description">If no argument is supplied, all timers and intervals are stopped</p>
  <h4>Parameters</h4>
   <p class="param"><b> id</b> The id returned by a previous call to setInterval</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_clearTimeout">function clearTimeout</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function clearTimeout(id)</code></p>
  <h4>Description</h4>
   <p class="description">Clear the Timeout that was created with setTimeout, for example:</p>
   <p class="description"><code>var id = <a href="#l__global_setTimeout">setTimeout</a>(function () { <a href="#l__global_print">print</a>('foo'); }, 1000);</code></p>
   <p class="description"><code>clearTimeout(id);</code></p>
   <p class="description">If no argument is supplied, all timers and intervals are stopped</p>
  <h4>Parameters</h4>
   <p class="param"><b> id</b> The id returned by a previous call to setTimeout</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_clearWatch">function clearWatch</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function clearWatch(id)</code></p>
  <h4>Description</h4>
   <p class="description">Clear the Watch that was created with <a href="#l__global_setWatch">setWatch</a>. If no parameter is supplied, all watches will be removed.</p>
  <h4>Parameters</h4>
   <p class="param"><b> id</b> The id returned by a previous call to setWatch</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_digitalPulse">function digitalPulse</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function digitalPulse(pin,value,time)</code></p>
  <h4>Description</h4>
   <p class="description">Pulse the pin with the value for the given time in milliseconds. It uses a hardware timer to produce accurate pulses, and returns immediately (before the pulse has finished). Use <code>digitalPulse(A0,1,0)</code> to wait until a previous pulse has finished.</p>
   <p class="description">eg. <code>digitalPulse(A0,1,5);</code> pulses A0 high for 5ms</p>
   <p class="description">digitalPulse is for SHORT pulses that need to be very accurate. If you're doing anything over a few milliseconds, use <a href="#l__global_setTimeout">setTimeout</a> instead.</p>
  <h4>Parameters</h4>
   <p class="param"><b> pin</b> The pin to use</p>
   <p class="param"><b> value</b> Whether to pulse high (true) or low (false)</p>
   <p class="param"><b> time</b> A time in milliseconds</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_digitalRead">function digitalRead</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function digitalRead(pin)</code></p>
  <h4>Description</h4>
   <p class="description">Get the digital value of the given pin</p>
   <p class="description">If pin is an array of pins, eg. <code>[A2,A1,A0]</code> the value will be treated as an integer where the first array element is the MSB</p>
  <h4>Parameters</h4>
   <p class="param"><b> pin</b> The pin to use</p>
  <h4>Returns</h4>
   <p class="return">The digital Value of the Pin</p>
  <h3 class="detail"><a name="l__global_digitalWrite">function digitalWrite</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function digitalWrite(pin,value)</code></p>
  <h4>Description</h4>
   <p class="description">Set the digital value of the given pin</p>
   <p class="description">If pin is an array of pins, eg. <code>[A2,A1,A0]</code> the value will be treated as an integer where the first array element is the MSB.</p>
   <p class="description">In the case of an array of pins, pin values are set LSB first (from the right-hand side of the array of pins).</p>
  <h4>Parameters</h4>
   <p class="param"><b> pin</b> The pin to use</p>
   <p class="param"><b> value</b> Whether to pulse high (true) or low (false)</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_dump">function dump</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function dump()</code></p>
  <h4>Description</h4>
   <p class="description">Output current interpreter state in a text form such that it can be copied to a new device</p>
   <p class="description">Note: 'Internal' functions are currently not handled correctly. You will need to recreate these in the onInit function.</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_echo">function echo</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function echo(echoOn)</code></p>
  <h4>Description</h4>
   <p class="description">Should TinyJS echo what you type back to you? true = yes (Default), false = no. When echo is off, the result of executing a command is not returned. Instead, you must use 'print' to send output.</p>
  <h4>Parameters</h4>
   <p class="param"><b> echoOn</b> </p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_edit">function edit</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function edit(funcName)</code></p>
  <h4>Description</h4>
   <p class="description">Fill the console with the contents of the given function, so you can edit it.</p>
   <p class="description">NOTE: This is a convenience function - it will not edit 'inner functions'. For that, you must edit the 'outer function' and re-execute it.</p>
  <h4>Parameters</h4>
   <p class="param"><b> funcName</b> The name of the function to edit (either a string or just the unquoted name)</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_eval">function eval</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function eval(code)</code></p>
  <h4>Description</h4>
   <p class="description">Evaluate a string containing JavaScript code</p>
  <h4>Parameters</h4>
   <p class="param"><b> code</b> </p>
  <h4>Returns</h4>
   <p class="return">The result of evaluating the string</p>
  <h3 class="detail"><a name="l__global_getPinMode">function getPinMode</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function getPinMode(pin)</code></p>
  <h4>Description</h4>
   <p class="description">Return the current mode of the given pin. See <code>pinMode</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> pin</b> The pin to check</p>
  <h4>Returns</h4>
   <p class="return">The pin mode, as a string</p>
  <h3 class="detail"><a name="l__global_getSerial">function getSerial</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function getSerial()</code></p>
  <h4>Description</h4>
   <p class="description">Get the serial number of this board</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The board's serial number</p>
  <h3 class="detail"><a name="l__global_getTime">function getTime</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function getTime()</code></p>
  <h4>Description</h4>
   <p class="description">Return the current system time in Seconds (as a floating point number)</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">See description above</p>
  <h3 class="detail"><a name="l__global_isNaN">function isNaN</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function isNaN(x)</code></p>
  <h4>Description</h4>
   <p class="description">Whether the x is <a href="#l__global_NaN">NaN</a> (Not a Number) or not</p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> </p>
  <h4>Returns</h4>
   <p class="return">True is the value is NaN, false if not.</p>
  <h3 class="detail"><a name="l__global_load">function load</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function load()</code></p>
  <h4>Description</h4>
   <p class="description">Load program memory out of flash</p>
   <p class="description">This command only executes when the Interpreter returns to the Idle state - for instance <code>a=1;load();a=2;</code> will still leave 'a' as undefined (or what it was set to in the saved program).</p>
   <p class="description">Espruino will resume from where it was when you last typed <code>save()</code>. If you want code to be executed right after loading (for instance to initialise devices connected to Espruino), create a function called <code>onInit</code> (which will be automatically executed by Espruino).</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_parseFloat">function parseFloat</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function parseFloat(string)</code></p>
  <h4>Description</h4>
   <p class="description">Convert a string representing a number into an float</p>
  <h4>Parameters</h4>
   <p class="param"><b> string</b> </p>
  <h4>Returns</h4>
   <p class="return">The value of the string</p>
  <h3 class="detail"><a name="l__global_parseInt">function parseInt</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function parseInt(string,radix)</code></p>
  <h4>Description</h4>
   <p class="description">Convert a string representing a number into an integer</p>
  <h4>Parameters</h4>
   <p class="param"><b> string</b> </p>
   <p class="param"><b> radix</b> The Radix of the string (optional)</p>
  <h4>Returns</h4>
   <p class="return">The integer value of the string (or NaN)</p>
  <h3 class="detail"><a name="l__global_peek16">function peek16</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function peek16(addr)</code></p>
  <h4>Description</h4>
   <p class="description">Read 16 bits of memory at the given location - DANGEROUS!</p>
  <h4>Parameters</h4>
   <p class="param"><b> addr</b> The address in memory to read</p>
  <h4>Returns</h4>
   <p class="return">The value of memory at the given location</p>
  <h3 class="detail"><a name="l__global_peek32">function peek32</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function peek32(addr)</code></p>
  <h4>Description</h4>
   <p class="description">Read 32 bits of memory at the given location - DANGEROUS!</p>
  <h4>Parameters</h4>
   <p class="param"><b> addr</b> The address in memory to read</p>
  <h4>Returns</h4>
   <p class="return">The value of memory at the given location</p>
  <h3 class="detail"><a name="l__global_peek8">function peek8</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function peek8(addr)</code></p>
  <h4>Description</h4>
   <p class="description">Read 8 bits of memory at the given location - DANGEROUS!</p>
  <h4>Parameters</h4>
   <p class="param"><b> addr</b> The address in memory to read</p>
  <h4>Returns</h4>
   <p class="return">The value of memory at the given location</p>
  <h3 class="detail"><a name="l__global_pinMode">function pinMode</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function pinMode(pin,mode)</code></p>
  <h4>Description</h4>
   <p class="description">Set the mode of the given pin - note that digitalRead/digitalWrite/etc set this automatically unless pinMode has been called first. If you want digitalRead/etc to set the pin mode automatically after you have called pinMode, simply call it again with no mode argument: <code>pinMode(pin)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> pin</b> The pin to set pin mode for</p>
   <p class="param"><b> mode</b> The mode - a string that is either 'input', 'input_pullup', 'input_pulldown', 'output', 'opendrain', 'af_output' or 'af_opendrain'. Do not include this argument if you want to revert to automatic pin mode setting.</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_poke16">function poke16</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function poke16(addr,value)</code></p>
  <h4>Description</h4>
   <p class="description">Write 16 bits of memory at the given location - VERY DANGEROUS!</p>
  <h4>Parameters</h4>
   <p class="param"><b> addr</b> The address in memory to write</p>
   <p class="param"><b> value</b> The value to write</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_poke32">function poke32</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function poke32(addr,value)</code></p>
  <h4>Description</h4>
   <p class="description">Write 32 bits of memory at the given location - VERY DANGEROUS!</p>
  <h4>Parameters</h4>
   <p class="param"><b> addr</b> The address in memory to write</p>
   <p class="param"><b> value</b> The value to write</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_poke8">function poke8</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function poke8(addr,value)</code></p>
  <h4>Description</h4>
   <p class="description">Write 8 bits of memory at the given location - VERY DANGEROUS!</p>
  <h4>Parameters</h4>
   <p class="param"><b> addr</b> The address in memory to write</p>
   <p class="param"><b> value</b> The value to write</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_print">function print</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function print(text,...)</code></p>
  <h4>Description</h4>
   <p class="description">Print the supplied string(s) to the console</p>
   <p class="description">**Note:** If you're connected to a computer (not a wall adaptor) via USB but **you are not running a terminal app** then when you print data Espruino may pause execution and wait until the computer requests the data it is trying to print.</p>
  <h4>Parameters</h4>
   <p class="param"><b> text, ...</b> </p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_require">function require</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function require(moduleName)</code></p>
  <h4>Description</h4>
   <p class="description">Load the given module, and return the exported functions</p>
  <h4>Parameters</h4>
   <p class="param"><b> moduleName</b> A String containing the name of the given module</p>
  <h4>Returns</h4>
   <p class="return">The result of evaluating the string</p>
  <h3 class="detail"><a name="l__global_reset">function reset</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function reset()</code></p>
  <h4>Description</h4>
   <p class="description">Reset the interpreter - clear program memory, and do not <a href="#l__global_load">load</a> a saved program from flash. This does NOT reset the underlying hardware (which allows you to reset the device without it disconnecting from USB).</p>
   <p class="description">This command only executes when the Interpreter returns to the Idle state - for instance <code>a=1;reset();a=2;</code> will still leave 'a' as undefined.</p>
   <p class="description">The safest way to do a full reset is to hit the reset button.</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_save">function save</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function save()</code></p>
  <h4>Description</h4>
   <p class="description">Save program memory into flash. It will then be loaded automatically every time Espruino powers on or is hard-reset.</p>
   <p class="description">This command only executes when the Interpreter returns to the Idle state - for instance <code>a=1;save();a=2;</code> will save 'a' as 2.</p>
   <p class="description">When Espruino powers on, it will resume from where it was when you typed <code>save()</code>. If you want code to be executed right after loading (for instance to initialise devices connected to Espruino), create a function called <code>onInit</code> (which will be automatically executed by Espruino).</p>
   <p class="description">In order to stop the program saved with this command being loaded automatically, hold down Button 1 while also pressing <a href="#l__global_reset">reset</a>. On some boards, Button 1 enters bootloader mode, so you will need to press Reset with Button 1 raised, and then hold Button 1 down a fraction of a second later.</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_setBusyIndicator">function setBusyIndicator</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function setBusyIndicator(pin)</code></p>
  <h4>Description</h4>
   <p class="description">When Espruino is busy, set the pin specified here high. Set this to undefined to disable the feature.</p>
  <h4>Parameters</h4>
   <p class="param"><b> pin</b> </p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_setDeepSleep">function setDeepSleep</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function setDeepSleep(sleep)</code></p>
  <h4>Description</h4>
   <p class="description">Set whether we can enter deep sleep mode, which reduces power consumption to around 100uA. This only works on the Espruino Board.</p>
   <p class="description">Please see <a href="http://www.espruino.com/Power+Consumption">http://www.espruino.com/Power+Consumption</a> for more details on this.</p>
  <h4>Parameters</h4>
   <p class="param"><b> sleep</b> </p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_setInterval">function setInterval</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function setInterval(function,timeout)</code></p>
  <h4>Description</h4>
   <p class="description">Call the function specified REPEATEDLY after the timeout in milliseconds.</p>
   <p class="description">The function that is being called may also take an argument, which is an object containing a field called 'time' (the time in seconds at which the timer happened)</p>
   <p class="description">for example: <code>setInterval(function (e) { <a href="#l__global_print">print</a>(e.time); }, 1000);</code></p>
   <p class="description">This can also be removed using clearInterval</p>
   <p class="description">**Note:** If <code>setDeepSleep(true)</code> has been called and the interval is greater than 5 seconds, Espruino may execute the interval up to 1 second late. This is because Espruino can only wake from deep sleep every second - and waking early would cause Espruino to waste power while it waited for the correct time.</p>
  <h4>Parameters</h4>
   <p class="param"><b> function</b> A Function or String to be executed</p>
   <p class="param"><b> timeout</b> The time between calls to the function</p>
  <h4>Returns</h4>
   <p class="return">An ID that can be passed to clearInterval</p>
  <h3 class="detail"><a name="l__global_setSleepIndicator">function setSleepIndicator</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function setSleepIndicator(pin)</code></p>
  <h4>Description</h4>
   <p class="description">When Espruino is asleep, set the pin specified here low (when it's awake, set it high). Set this to undefined to disable the feature.</p>
   <p class="description">Please see <a href="http://www.espruino.com/Power+Consumption">http://www.espruino.com/Power+Consumption</a> for more details on this.</p>
  <h4>Parameters</h4>
   <p class="param"><b> pin</b> </p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l__global_setTimeout">function setTimeout</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function setTimeout(function,timeout)</code></p>
  <h4>Description</h4>
   <p class="description">Call the function specified ONCE after the timeout in milliseconds.</p>
   <p class="description">The function that is being called may also take an argument, which is an object containing a field called 'time' (the time in seconds at which the timer happened)</p>
   <p class="description">for example: <code>setTimeout(function (e) { <a href="#l__global_print">print</a>(e.time); }, 1000);</code></p>
   <p class="description">This can also be removed using clearTimeout</p>
   <p class="description">**Note:** If <code>setDeepSleep(true)</code> has been called and the interval is greater than 5 seconds, Espruino may execute the interval up to 1 second late. This is because Espruino can only wake from deep sleep every second - and waking early would cause Espruino to waste power while it waited for the correct time.</p>
  <h4>Parameters</h4>
   <p class="param"><b> function</b> A Function or String to be executed</p>
   <p class="param"><b> timeout</b> The time until the function will be executed</p>
  <h4>Returns</h4>
   <p class="return">An ID that can be passed to clearTimeout</p>
  <h3 class="detail"><a name="l__global_setWatch">function setWatch</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function setWatch(function,pin,options)</code></p>
  <h4>Description</h4>
   <p class="description">Call the function specified when the pin changes</p>
   <p class="description">The function may also take an argument, which is an object of type <code>{time:float, lastTime:float, state:bool}</code>.</p>
   <p class="description"><code>time</code> is the time in seconds at which the pin changed state, <code>lastTime</code> is the time in seconds at which the pin last changed state, and <code>state</code> is the current state of the pin.</p>
   <p class="description">For instance, if you want to measure the length of a positive pusle you could use: <code>setWatch(function(e) { <a href="#l_console_log">console.log</a>(e.time-e.lastTime); }, BTN, { repeat:true, edge:'falling' });</code></p>
   <p class="description">This can also be removed using clearWatch</p>
  <h4>Parameters</h4>
   <p class="param"><b> function</b> A Function or String to be executed</p>
   <p class="param"><b> pin</b> The pin to watch</p>
   <p class="param"><b> options</b> If this is a boolean or integer, it determines whether to call this once (false = default) or every time a change occurs (true)<br/>If this is an object, it can contain the following information: <code>{ repeat: true/false(default), edge:'rising'/'falling'/'both'(default), debounce:10}</code>. <code>debounce</code> is the time in ms to wait for bounces to subside, or 0.</p>
  <h4>Returns</h4>
   <p class="return">An ID that can be passed to clearWatch</p>
  <h3 class="detail"><a name="l__global_trace">function trace</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function trace(root)</code></p>
  <h4>Description</h4>
   <p class="description">Output debugging information</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> root</b> The symbol to output (optional). If nothing is specified, everything will be output</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
<h2 class="class"><a name="Array">Array Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This is the built-in JavaScript class for arrays.</p>
   <p class="description">Arrays can be defined with <code>[]</code>, <code>new Array()</code>, or <code>new Array(length)</code></p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Array_Array">constructor Array(args,...)</a></li>
    <li><a href="#l_Array_concat">function Array.concat(args,...)</a></li>
    <li><a href="#l_Array_every">function Array.every(function,thisArg)</a></li>
    <li><a href="#l_Array_fill">function Array.fill(value,start,end)</a></li>
    <li><a href="#l_Array_filter">function Array.filter(function,thisArg)</a></li>
    <li><a href="#l_Array_forEach">function Array.forEach(function,thisArg)</a></li>
    <li><a href="#l_Array_indexOf">function Array.indexOf(value)</a></li>
    <li><a href="#l_Array_isArray">Array.isArray(var)</a></li>
    <li><a href="#l_Array_join">function Array.join(separator)</a></li>
    <li><a href="#l_Array_length">property Array.length</a></li>
    <li><a href="#l_Array_map">function Array.map(function,thisArg)</a></li>
    <li><a href="#l_Array_pop">function Array.pop()</a></li>
    <li><a href="#l_Array_push">function Array.push(arguments,...)</a></li>
    <li><a href="#l_Array_reduce">function Array.reduce(callback,initialValue)</a></li>
    <li><a href="#l_Array_shift">function Array.shift()</a></li>
    <li><a href="#l_Array_slice">function Array.slice(start,end)</a></li>
    <li><a href="#l_Array_some">function Array.some(function,thisArg)</a></li>
    <li><a href="#l_Array_sort">function Array.sort(var)</a></li>
    <li><a href="#l_Array_splice">function Array.splice(index,howMany,elements,...)</a></li>
    <li><a href="#l_Array_toString">function Array.toString(radix)</a></li>
    <li><a href="#l_Array_unshift">function Array.unshift(elements,...)</a></li>
  </ul>
  <h3 class="detail"><a name="l_Array_Array">constructor Array</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>constructor Array(args,...)</code></p>
  <h4>Description</h4>
   <p class="description">Create an Array. Either give it one integer argument (>=0) which is the length of the array, or any number of <a href="#l__global_arguments">arguments</a> </p>
  <h4>Parameters</h4>
   <p class="param"><b> args, ...</b> The length of the array OR any number of items to add to the array</p>
  <h4>Returns</h4>
   <p class="return">An Array</p>
  <h3 class="detail"><a name="l_Array_concat">function Array.concat</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Array.concat(args,...)</code></p>
  <h4>Description</h4>
   <p class="description">Create a new array, containing the elements from this one and any arguments, if any argument is an array then those elements will be added.</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> args, ...</b> Any items to add to the array</p>
  <h4>Returns</h4>
   <p class="return">An Array</p>
  <h3 class="detail"><a name="l_Array_every">function Array.every</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Array.every(function,thisArg)</code></p>
  <h4>Description</h4>
   <p class="description">Return 'true' if the callback returns 'true' for every element in the array</p>
  <h4>Parameters</h4>
   <p class="param"><b> function</b> Function to be executed</p>
   <p class="param"><b> thisArg</b> if specified, the function is called with 'this' set to thisArg (optional)</p>
  <h4>Returns</h4>
   <p class="return">A boolean containing the result</p>
  <h3 class="detail"><a name="l_Array_fill">function Array.fill</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Array.fill(value,start,end)</code></p>
  <h4>Description</h4>
   <p class="description">Fill this array with the given value, for every index <code>>= start</code> and <code>< end</code></p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> value</b> The value to fill the array with</p>
   <p class="param"><b> start</b> Optional. The index to start from (or 0). If start is negative, it is treated as length+start where length is the length of the array</p>
   <p class="param"><b> end</b> Optional. The index to end at (or the array length). If end is negative, it is treated as length+end.</p>
  <h4>Returns</h4>
   <p class="return">This array</p>
  <h3 class="detail"><a name="l_Array_filter">function Array.filter</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Array.filter(function,thisArg)</code></p>
  <h4>Description</h4>
   <p class="description">Return an array which contains only those elements for which the callback function returns 'true'</p>
  <h4>Parameters</h4>
   <p class="param"><b> function</b> Function to be executed</p>
   <p class="param"><b> thisArg</b> if specified, the function is called with 'this' set to thisArg (optional)</p>
  <h4>Returns</h4>
   <p class="return">An array containing the results</p>
  <h3 class="detail"><a name="l_Array_forEach">function Array.forEach</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Array.forEach(function,thisArg)</code></p>
  <h4>Description</h4>
   <p class="description">Executes a provided function once per array element.</p>
  <h4>Parameters</h4>
   <p class="param"><b> function</b> Function to be executed</p>
   <p class="param"><b> thisArg</b> if specified, the function is called with 'this' set to thisArg (optional)</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Array_indexOf">function Array.indexOf</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Array.indexOf(value)</code></p>
  <h4>Description</h4>
   <p class="description">Return the index of the value in the array, or -1</p>
  <h4>Parameters</h4>
   <p class="param"><b> value</b> The value to check for</p>
  <h4>Returns</h4>
   <p class="return">the index of the value in the array, or -1</p>
  <h3 class="detail"><a name="l_Array_isArray">Array.isArray</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Array.isArray(var)</code></p>
  <h4>Description</h4>
   <p class="description">Returns true if the provided object is an array</p>
  <h4>Parameters</h4>
   <p class="param"><b> var</b> The variable to be tested</p>
  <h4>Returns</h4>
   <p class="return">True if var is an array, false if not.</p>
  <h3 class="detail"><a name="l_Array_join">function Array.join</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Array.join(separator)</code></p>
  <h4>Description</h4>
   <p class="description">Join all elements of this array together into one string, using 'separator' between them. eg. <code>[1,2,3].join(' ')=='1 2 3'</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> separator</b> The separator</p>
  <h4>Returns</h4>
   <p class="return">A String representing the Joined array</p>
  <h3 class="detail"><a name="l_Array_length">property Array.length</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>property Array.length</code></p>
  <h4>Description</h4>
   <p class="description">Find the length of the array</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The value of the array</p>
  <h3 class="detail"><a name="l_Array_map">function Array.map</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Array.map(function,thisArg)</code></p>
  <h4>Description</h4>
   <p class="description">Return an array which is made from the following: <code>A.map(function) = [function(A[0]), function(A[1]), ...]</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> function</b> Function used to map one item to another</p>
   <p class="param"><b> thisArg</b> if specified, the function is called with 'this' set to thisArg (optional)</p>
  <h4>Returns</h4>
   <p class="return">An array containing the results</p>
  <h3 class="detail"><a name="l_Array_pop">function Array.pop</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Array.pop()</code></p>
  <h4>Description</h4>
   <p class="description">Pop a new value off of the end of this array</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The value that is popped off</p>
  <h3 class="detail"><a name="l_Array_push">function Array.push</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Array.push(arguments,...)</code></p>
  <h4>Description</h4>
   <p class="description">Push a new value onto the end of this array'</p>
  <h4>Parameters</h4>
   <p class="param"><b> arguments, ...</b> One or more arguments to add</p>
  <h4>Returns</h4>
   <p class="return">The new size of the array</p>
  <h3 class="detail"><a name="l_Array_reduce">function Array.reduce</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Array.reduce(callback,initialValue)</code></p>
  <h4>Description</h4>
   <p class="description">Execute <code>previousValue=initialValue</code> and then <code>previousValue = callback(previousValue, currentValue, index, array)</code> for each element in the array, and finally return previousValue.</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> callback</b> Function used to reduce the array</p>
   <p class="param"><b> initialValue</b> if specified, the initial value to pass to the function</p>
  <h4>Returns</h4>
   <p class="return">The value returned by the last function called</p>
  <h3 class="detail"><a name="l_Array_shift">function Array.shift</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Array.shift()</code></p>
  <h4>Description</h4>
   <p class="description">Remove the first element of the array, and return it</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
  <h4>Returns</h4>
   <p class="return">The element that was removed</p>
  <h3 class="detail"><a name="l_Array_slice">function Array.slice</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Array.slice(start,end)</code></p>
  <h4>Description</h4>
   <p class="description">Return a copy of a portion of the calling array</p>
  <h4>Parameters</h4>
   <p class="param"><b> start</b> Start index</p>
   <p class="param"><b> end</b> End index (optional)</p>
  <h4>Returns</h4>
   <p class="return">A new array</p>
  <h3 class="detail"><a name="l_Array_some">function Array.some</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Array.some(function,thisArg)</code></p>
  <h4>Description</h4>
   <p class="description">Return 'true' if the callback returns 'true' for any of the elements in the array</p>
  <h4>Parameters</h4>
   <p class="param"><b> function</b> Function to be executed</p>
   <p class="param"><b> thisArg</b> if specified, the function is called with 'this' set to thisArg (optional)</p>
  <h4>Returns</h4>
   <p class="return">A boolean containing the result</p>
  <h3 class="detail"><a name="l_Array_sort">function Array.sort</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Array.sort(var)</code></p>
  <h4>Description</h4>
   <p class="description">Do an in-place quicksort of the array</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> var</b> A function to use to compare array elements (or undefined)</p>
  <h4>Returns</h4>
   <p class="return">This array object</p>
  <h3 class="detail"><a name="l_Array_splice">function Array.splice</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Array.splice(index,howMany,elements,...)</code></p>
  <h4>Description</h4>
   <p class="description">Both remove and add items to an array</p>
  <h4>Parameters</h4>
   <p class="param"><b> index</b> Index at which to start changing the array. If negative, will begin that many elements from the end</p>
   <p class="param"><b> howMany</b> An integer indicating the number of old array elements to remove. If howMany is 0, no elements are removed.</p>
   <p class="param"><b> elements, ...</b> One or more items to add to the array</p>
  <h4>Returns</h4>
   <p class="return">An array containing the removed elements. If only one element is removed, an array of one element is returned.</p>
  <h3 class="detail"><a name="l_Array_toString">function Array.toString</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Array.toString(radix)</code></p>
  <h4>Description</h4>
   <p class="description">Convert the Array to a string</p>
  <h4>Parameters</h4>
   <p class="param"><b> radix</b> unused</p>
  <h4>Returns</h4>
   <p class="return">A String representing the array</p>
  <h3 class="detail"><a name="l_Array_unshift">function Array.unshift</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Array.unshift(elements,...)</code></p>
  <h4>Description</h4>
   <p class="description">Remove the first element of the array, and return it</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> elements, ...</b> One or more items to add to the beginning of the array</p>
  <h4>Returns</h4>
   <p class="return">The new array length</p>
<h2 class="class"><a name="ArrayBuffer">ArrayBuffer Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This is the built-in JavaScript class for array buffers.</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_ArrayBuffer_ArrayBuffer">constructor ArrayBuffer(byteLength)</a></li>
  </ul>
  <h3 class="detail"><a name="l_ArrayBuffer_ArrayBuffer">constructor ArrayBuffer</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>constructor ArrayBuffer(byteLength)</code></p>
  <h4>Description</h4>
   <p class="description">Create an Array Buffer object</p>
  <h4>Parameters</h4>
   <p class="param"><b> byteLength</b> The length in Bytes</p>
  <h4>Returns</h4>
   <p class="return">An ArrayBuffer object</p>
<h2 class="class"><a name="ArrayBufferView">ArrayBufferView Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This is the built-in JavaScript class that is the prototype for Uint8Array / Float32Array / etc</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_ArrayBufferView_buffer">property ArrayBufferView.buffer</a></li>
    <li><a href="#l_ArrayBufferView_byteLength">property ArrayBufferView.byteLength</a></li>
    <li><a href="#l_ArrayBufferView_byteOffset">property ArrayBufferView.byteOffset</a></li>
    <li><a href="#l_ArrayBufferView_fill">function ArrayBufferView.fill(value,start,end)</a></li>
    <li><a href="#l_ArrayBufferView_forEach">function ArrayBufferView.forEach(function,thisArg)</a></li>
    <li><a href="#l_ArrayBufferView_indexOf">function ArrayBufferView.indexOf(value)</a></li>
    <li><a href="#l_ArrayBufferView_join">function ArrayBufferView.join(separator)</a></li>
    <li><a href="#l_ArrayBufferView_map">function ArrayBufferView.map(function,thisArg)</a></li>
    <li><a href="#l_ArrayBufferView_reduce">function ArrayBufferView.reduce(callback,initialValue)</a></li>
    <li><a href="#l_ArrayBufferView_set">function ArrayBufferView.set(arr,offset)</a></li>
    <li><a href="#l_ArrayBufferView_sort">function ArrayBufferView.sort(var)</a></li>
  </ul>
  <h3 class="detail"><a name="l_ArrayBufferView_buffer">property ArrayBufferView.buffer</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>property ArrayBufferView.buffer</code></p>
  <h4>Description</h4>
   <p class="description">The buffer this view references</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">An ArrayBuffer object</p>
  <h3 class="detail"><a name="l_ArrayBufferView_byteLength">property ArrayBufferView.byteLength</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>property ArrayBufferView.byteLength</code></p>
  <h4>Description</h4>
   <p class="description">The length, in bytes, of the view</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The Length</p>
  <h3 class="detail"><a name="l_ArrayBufferView_byteOffset">property ArrayBufferView.byteOffset</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>property ArrayBufferView.byteOffset</code></p>
  <h4>Description</h4>
   <p class="description">The offset, in bytes, to the first byte of the view within the ArrayBuffer</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The byte Offset</p>
  <h3 class="detail"><a name="l_ArrayBufferView_fill">function ArrayBufferView.fill</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function ArrayBufferView.fill(value,start,end)</code></p>
  <h4>Description</h4>
   <p class="description">Fill this array with the given value, for every index <code>>= start</code> and <code>< end</code></p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> value</b> The value to fill the array with</p>
   <p class="param"><b> start</b> Optional. The index to start from (or 0). If start is negative, it is treated as length+start where length is the length of the array</p>
   <p class="param"><b> end</b> Optional. The index to end at (or the array length). If end is negative, it is treated as length+end.</p>
  <h4>Returns</h4>
   <p class="return">This array</p>
  <h3 class="detail"><a name="l_ArrayBufferView_forEach">function ArrayBufferView.forEach</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function ArrayBufferView.forEach(function,thisArg)</code></p>
  <h4>Description</h4>
   <p class="description">Executes a provided function once per array element.</p>
  <h4>Parameters</h4>
   <p class="param"><b> function</b> Function to be executed</p>
   <p class="param"><b> thisArg</b> if specified, the function is called with 'this' set to thisArg (optional)</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_ArrayBufferView_indexOf">function ArrayBufferView.indexOf</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function ArrayBufferView.indexOf(value)</code></p>
  <h4>Description</h4>
   <p class="description">Return the index of the value in the array, or -1</p>
  <h4>Parameters</h4>
   <p class="param"><b> value</b> The value to check for</p>
  <h4>Returns</h4>
   <p class="return">the index of the value in the array, or -1</p>
  <h3 class="detail"><a name="l_ArrayBufferView_join">function ArrayBufferView.join</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function ArrayBufferView.join(separator)</code></p>
  <h4>Description</h4>
   <p class="description">Join all elements of this array together into one string, using 'separator' between them. eg. <code>[1,2,3].join(' ')=='1 2 3'</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> separator</b> The separator</p>
  <h4>Returns</h4>
   <p class="return">A String representing the Joined array</p>
  <h3 class="detail"><a name="l_ArrayBufferView_map">function ArrayBufferView.map</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function ArrayBufferView.map(function,thisArg)</code></p>
  <h4>Description</h4>
   <p class="description">Return an array which is made from the following: <code>A.map(function) = [function(A[0]), function(A[1]), ...]</code></p>
   <p class="description">**Note:** This returns an ArrayBuffer of the same type it was called on. To get an Array, use <code>Array.prototype.map</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> function</b> Function used to map one item to another</p>
   <p class="param"><b> thisArg</b> if specified, the function is called with 'this' set to thisArg (optional)</p>
  <h4>Returns</h4>
   <p class="return">An array containing the results</p>
  <h3 class="detail"><a name="l_ArrayBufferView_reduce">function ArrayBufferView.reduce</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function ArrayBufferView.reduce(callback,initialValue)</code></p>
  <h4>Description</h4>
   <p class="description">Execute <code>previousValue=initialValue</code> and then <code>previousValue = callback(previousValue, currentValue, index, array)</code> for each element in the array, and finally return previousValue.</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> callback</b> Function used to reduce the array</p>
   <p class="param"><b> initialValue</b> if specified, the initial value to pass to the function</p>
  <h4>Returns</h4>
   <p class="return">The value returned by the last function called</p>
  <h3 class="detail"><a name="l_ArrayBufferView_set">function ArrayBufferView.set</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function ArrayBufferView.set(arr,offset)</code></p>
  <h4>Description</h4>
   <p class="description">Copy the contents of <code>array</code> into this one, mapping <code>this[x+offset]=array[x];</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> arr</b> Floating point index to access</p>
   <p class="param"><b> offset</b> The offset in this array at which to write the values (optional)</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_ArrayBufferView_sort">function ArrayBufferView.sort</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function ArrayBufferView.sort(var)</code></p>
  <h4>Description</h4>
   <p class="description">Do an in-place quicksort of the array</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> var</b> A function to use to compare array elements (or undefined)</p>
  <h4>Returns</h4>
   <p class="return">This array object</p>
<h2 class="class"><a name="CC3000">CC3000 Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description"></p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_CC3000_connect">CC3000.connect()</a></li>
  </ul>
  <h3 class="detail"><a name="l_CC3000_connect">CC3000.connect</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>CC3000.connect()</code></p>
  <h4>Description</h4>
   <p class="description">Initialise the CC3000 and return a WLAN object</p>
  <h4>Parameters</h4>
  <h4>Returns</h4>
   <p class="return">A WLAN Object</p>
<h2 class="class"><a name="Double">Double Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This is the built-in class for Floating Point values</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Double_doubleToIntBits">Double.doubleToIntBits(x)</a></li>
  </ul>
  <h3 class="detail"><a name="l_Double_doubleToIntBits">Double.doubleToIntBits</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Double.doubleToIntBits(x)</code></p>
  <h4>Description</h4>
   <p class="description"> Convert the floating point value given into an integer representing the bits contained in it</p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> A floating point number</p>
  <h4>Returns</h4>
   <p class="return">The integer representation of x</p>
<h2 class="class"><a name="E">E Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This is the built-in JavaScript class for Espruino utility functions.</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_E_FFT">E.FFT(arrReal,arrImage,inverse)</a></li>
    <li><a href="#l_E_clip">E.clip(x,min,max)</a></li>
    <li><a href="#l_E_convolve">E.convolve(arr1,arr2,offset)</a></li>
    <li><a href="#l_E_enableWatchdog">E.enableWatchdog(timeout)</a></li>
    <li><a href="#l_E_getAnalogVRef">E.getAnalogVRef()</a></li>
    <li><a href="#l_E_getTemperature">E.getTemperature()</a></li>
    <li><a href="#l_E_interpolate">E.interpolate(array,index)</a></li>
    <li><a href="#l_E_interpolate2d">E.interpolate2d(array,width,x,y)</a></li>
    <li><a href="#l_E_nativeCall">E.nativeCall(addr,sig)</a></li>
    <li><a href="#l_E_openFile">E.openFile(path,mode)</a></li>
    <li><a href="#l_E_reverseByte">E.reverseByte(x)</a></li>
    <li><a href="#l_E_sum">E.sum(arr)</a></li>
    <li><a href="#l_E_toArrayBuffer">E.toArrayBuffer(str)</a></li>
    <li><a href="#l_E_variance">E.variance(arr,mean)</a></li>
  </ul>
  <h3 class="detail"><a name="l_E_FFT">E.FFT</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>E.FFT(arrReal,arrImage,inverse)</code></p>
  <h4>Description</h4>
   <p class="description">Performs a Fast Fourier Transform (fft) on the supplied data and writes it back into the original arrays. Note that if only one array is supplied, the data written back is the modulus of the complex result <code>sqrt(r*r+i*i)</code>.</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> arrReal</b> An array of real values</p>
   <p class="param"><b> arrImage</b> An array of imaginary values (or if undefined, all values will be taken to be 0)</p>
   <p class="param"><b> inverse</b> Set this to true if you want an inverse FFT - otherwise leave as 0</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_E_clip">E.clip</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>E.clip(x,min,max)</code></p>
  <h4>Description</h4>
   <p class="description">Clip a number to be between min and max (inclusive)</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> A floating point value to clip</p>
   <p class="param"><b> min</b> The smallest the value should be</p>
   <p class="param"><b> max</b> The largest the value should be</p>
  <h4>Returns</h4>
   <p class="return">The value of x, clipped so as not to be below min or above max.</p>
  <h3 class="detail"><a name="l_E_convolve">E.convolve</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>E.convolve(arr1,arr2,offset)</code></p>
  <h4>Description</h4>
   <p class="description">Convolve arr1 with arr2. This is equivalent to <code>v=0;for (i in arr1) v+=arr1[i] * arr2[(i+offset) % arr2.length]</code></p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> arr1</b> An array to convolve</p>
   <p class="param"><b> arr2</b> An array to convolve</p>
   <p class="param"><b> offset</b> The mean value of the array</p>
  <h4>Returns</h4>
   <p class="return">The variance of the given buffer</p>
  <h3 class="detail"><a name="l_E_enableWatchdog">E.enableWatchdog</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>E.enableWatchdog(timeout)</code></p>
  <h4>Description</h4>
   <p class="description">Enable the watchdog timer. This will <a href="#l__global_reset">reset</a> Espruino if it isn't able to return to the idle loop within the timeout. NOTE: This will not work with <code>setDeepSleep</code> unless you explicitly wake Espruino up with an interval of less than the timeout.</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> timeout</b> The timeout in seconds before a watchdog reset</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_E_getAnalogVRef">E.getAnalogVRef</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>E.getAnalogVRef()</code></p>
  <h4>Description</h4>
   <p class="description">Check the internal voltage reference. To work out an actual voltage of an input pin, you can use <code>analogRead(pin)*E.getAnalogVRef()</code> </p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The voltage (in Volts) that a reading of 1 from <code>analogRead</code> actually represents</p>
  <h3 class="detail"><a name="l_E_getTemperature">E.getTemperature</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>E.getTemperature()</code></p>
  <h4>Description</h4>
   <p class="description">Use the STM32's internal thermistor to work out the temperature.</p>
   <p class="description">**Note:** This is very inaccurate (+/- 20 degrees C) and varies from chip to chip. It can be used to work out when temperature rises or falls, but don't expect absolute temperature readings to be useful.</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The temperature in degrees C</p>
  <h3 class="detail"><a name="l_E_interpolate">E.interpolate</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>E.interpolate(array,index)</code></p>
  <h4>Description</h4>
   <p class="description">Interpolate between two adjacent values in the Typed Array</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> array</b> A Typed Array to interpolate between</p>
   <p class="param"><b> index</b> Floating point index to access</p>
  <h4>Returns</h4>
   <p class="return">The result of interpolating between (int)index and (int)(index+1)</p>
  <h3 class="detail"><a name="l_E_interpolate2d">E.interpolate2d</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>E.interpolate2d(array,width,x,y)</code></p>
  <h4>Description</h4>
   <p class="description">Interpolate between four adjacent values in the Typed Array, in 2D.</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> array</b> A Typed Array to interpolate between</p>
   <p class="param"><b> width</b> Integer 'width' of 2d array</p>
   <p class="param"><b> x</b> Floating point X index to access</p>
   <p class="param"><b> y</b> Floating point Y index to access</p>
  <h4>Returns</h4>
   <p class="return">The result of interpolating in 2d between the 4 surrounding cells</p>
  <h3 class="detail"><a name="l_E_nativeCall">E.nativeCall</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>E.nativeCall(addr,sig)</code></p>
  <h4>Description</h4>
   <p class="description">ADVANCED: This is a great way to crash Espruino if you're not sure what you are doing</p>
   <p class="description">Create a native function that executes the code at the given address. Eg. <code>E.nativeCall(0x08012345,'double (double,double)')(1.1, 2.2)</code> </p>
   <p class="description">If you're executing a thumb function, you'll almost certainly need to set the bottom bit of the address to 1.</p>
   <p class="description">Note it's not guaranteed that the call signature you provide can be used - it has to be something that a function in Espruino already uses.</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> addr</b> The address in memory of the function</p>
   <p class="param"><b> sig</b> The signature of the call, <code>returnType (arg1,arg2,...)</code>. Allowed types are <code>void</code>,<code>bool</code>,<code>int</code>,<code>long</code>,<code>double</code>,<code>Pin</code>,<code>JsVar</code></p>
  <h4>Returns</h4>
   <p class="return">The native function</p>
  <h3 class="detail"><a name="l_E_openFile">E.openFile</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>E.openFile(path,mode)</code></p>
  <h4>Description</h4>
   <p class="description">Open a file</p>
  <h4>Parameters</h4>
   <p class="param"><b> path</b> the path to the file to open.</p>
   <p class="param"><b> mode</b> The mode to use when opening the file. Valid values for mode are 'r' for read, 'w' for write new, 'w+' for write existing, and 'a' for append. If not specified, the default is 'r'.</p>
  <h4>Returns</h4>
   <p class="return">A File object</p>
  <h3 class="detail"><a name="l_E_reverseByte">E.reverseByte</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>E.reverseByte(x)</code></p>
  <h4>Description</h4>
   <p class="description">Reverse the 8 bits in a byte, swapping MSB and LSB.</p>
   <p class="description">For example, <code>E.reverseByte(0b10010000) == 0b00001001</code>.</p>
   <p class="description">Note that you can reverse all the bytes in an array with: <code>arr = arr.map(E.reverseByte)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> A byte value to reverse the bits of</p>
  <h4>Returns</h4>
   <p class="return">The byte with reversed bits</p>
  <h3 class="detail"><a name="l_E_sum">E.sum</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>E.sum(arr)</code></p>
  <h4>Description</h4>
   <p class="description">Sum the contents of the given Array, String or ArrayBuffer and return the result</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> arr</b> The array to sum</p>
  <h4>Returns</h4>
   <p class="return">The sum of the given buffer</p>
  <h3 class="detail"><a name="l_E_toArrayBuffer">E.toArrayBuffer</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>E.toArrayBuffer(str)</code></p>
  <h4>Description</h4>
   <p class="description">Create an ArrayBuffer from the given string. This is done via a reference, not a copy - so it is very fast and memory efficient.</p>
   <p class="description">Note that this is an ArrayBuffer, not a Uint8Array. To get one of those, do: <code>new Uint8Array(E.toArrayBuffer('....'))</code>.</p>
  <h4>Parameters</h4>
   <p class="param"><b> str</b> The string to convert to an ArrayBuffer</p>
  <h4>Returns</h4>
   <p class="return">An ArrayBuffer that uses the given string</p>
  <h3 class="detail"><a name="l_E_variance">E.variance</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>E.variance(arr,mean)</code></p>
  <h4>Description</h4>
   <p class="description">Work out the variance of the contents of the given Array, String or ArrayBuffer and return the result. This is equivalent to <code>v=0;for (i in arr) v+=Math.pow(mean-arr[i],2)</code></p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> arr</b> The array to work out the variance for</p>
   <p class="param"><b> mean</b> The mean value of the array</p>
  <h4>Returns</h4>
   <p class="return">The variance of the given buffer</p>
<h2 class="class"><a name="Ethernet">Ethernet Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">An instantiation of an Ethernet network adaptor</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Ethernet_getIP">function Ethernet.getIP()</a></li>
    <li><a href="#l_Ethernet_setIP">function Ethernet.setIP(options)</a></li>
  </ul>
  <h3 class="detail"><a name="l_Ethernet_getIP">function Ethernet.getIP</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Ethernet.getIP()</code></p>
  <h4>Description</h4>
   <p class="description">Get the current IP address</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">See description above</p>
  <h3 class="detail"><a name="l_Ethernet_setIP">function Ethernet.setIP</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Ethernet.setIP(options)</code></p>
  <h4>Description</h4>
   <p class="description">Set the current IP address for get an IP from DHCP (if no options object is specified)</p>
  <h4>Parameters</h4>
   <p class="param"><b> options</b> Object containing IP address options <code>{ ip : '1,2,3,4', subnet, gateway, dns  }</code>, or do not supply an object in otder to force DHCP.</p>
  <h4>Returns</h4>
   <p class="return">True on success</p>
<h2 class="class"><a name="File">File Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This is the File object - it allows you to stream data to and from files (As opposed to the <code>require('fs').readFile(..)</code> style functions that read an entire file).</p>
   <p class="description">To create a File object, you must type <code>var fd = <a href="#l_E_openFile">E.openFile</a>('filepath','mode')</code> - see <a href="#l_E_openFile">E.openFile</a> for more information.</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_File_close">function File.close()</a></li>
    <li><a href="#l_File_pipe">function File.pipe(destination,options)</a></li>
    <li><a href="#l_File_read">function File.read(length)</a></li>
    <li><a href="#l_File_skip">function File.skip(nBytes)</a></li>
    <li><a href="#l_File_write">function File.write(buffer)</a></li>
  </ul>
  <h3 class="detail"><a name="l_File_close">function File.close</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function File.close()</code></p>
  <h4>Description</h4>
   <p class="description">Close an open file.</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_File_pipe">function File.pipe</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function File.pipe(destination,options)</code></p>
  <h4>Description</h4>
   <p class="description">Pipe this file to a stream (and object with a 'write' method)</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> destination</b> The destination file/stream that will receive content from the source.</p>
   <p class="param"><b> options</b> An optional object <code>{ chunkSize : int=32, end : bool=true, complete : function }</code><br/>chunkSize : The amount of data to pipe from source to destination at a time<br/>complete : a function to call when the pipe activity is complete<br/>end : call the 'end' function on the destination when the source is finished</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_File_read">function File.read</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function File.read(length)</code></p>
  <h4>Description</h4>
   <p class="description">Read data in a file in byte size chunks</p>
  <h4>Parameters</h4>
   <p class="param"><b> length</b> is an integer specifying the number of bytes to read.</p>
  <h4>Returns</h4>
   <p class="return">A string containing the characters that were read</p>
  <h3 class="detail"><a name="l_File_skip">function File.skip</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function File.skip(nBytes)</code></p>
  <h4>Description</h4>
   <p class="description">Skip the specified number of bytes forwards</p>
  <h4>Parameters</h4>
   <p class="param"><b> nBytes</b> is an integer specifying the number of bytes to skip forwards.</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_File_write">function File.write</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function File.write(buffer)</code></p>
  <h4>Description</h4>
   <p class="description">write data to a file</p>
  <h4>Parameters</h4>
   <p class="param"><b> buffer</b> A string containing the bytes to write</p>
  <h4>Returns</h4>
   <p class="return">the number of bytes written</p>
<h2 class="class"><a name="Float32Array">Float32Array Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This is the built-in JavaScript class for a typed array.</p>
   <p class="description">Instantiate this in order to efficiently store arrays of data (Espruino's normal arrays store data in a map, which is inefficient for non-sparse arrays). </p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Float32Array_Float32Array">constructor Float32Array(arr,byteOffset,length)</a></li>
  </ul>
  <h3 class="detail"><a name="l_Float32Array_Float32Array">constructor Float32Array</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>constructor Float32Array(arr,byteOffset,length)</code></p>
  <h4>Description</h4>
   <p class="description">Create a typed array based on the given input. Either an existing Array Buffer, an Integer as a Length, or a simple array. If an ArrayBuffer view (eg. Uint8Array rather than ArrayBuffer) is given, it will be completely copied rather than referenced.</p>
  <h4>Parameters</h4>
   <p class="param"><b> arr</b> The array or typed array to base this off, or an integer which is the array length</p>
   <p class="param"><b> byteOffset</b> The byte offset in the ArrayBuffer  (ONLY IF the first argument was an ArrayBuffer)</p>
   <p class="param"><b> length</b> The length (ONLY IF the first argument was an ArrayBuffer)</p>
  <h4>Returns</h4>
   <p class="return">A typed array</p>
<h2 class="class"><a name="Float64Array">Float64Array Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This is the built-in JavaScript class for a typed array.</p>
   <p class="description">Instantiate this in order to efficiently store arrays of data (Espruino's normal arrays store data in a map, which is inefficient for non-sparse arrays). </p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Float64Array_Float64Array">constructor Float64Array(arr,byteOffset,length)</a></li>
  </ul>
  <h3 class="detail"><a name="l_Float64Array_Float64Array">constructor Float64Array</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>constructor Float64Array(arr,byteOffset,length)</code></p>
  <h4>Description</h4>
   <p class="description">Create a typed array based on the given input. Either an existing Array Buffer, an Integer as a Length, or a simple array. If an ArrayBuffer view (eg. Uint8Array rather than ArrayBuffer) is given, it will be completely copied rather than referenced.</p>
  <h4>Parameters</h4>
   <p class="param"><b> arr</b> The array or typed array to base this off, or an integer which is the array length</p>
   <p class="param"><b> byteOffset</b> The byte offset in the ArrayBuffer  (ONLY IF the first argument was an ArrayBuffer)</p>
   <p class="param"><b> length</b> The length (ONLY IF the first argument was an ArrayBuffer)</p>
  <h4>Returns</h4>
   <p class="return">A typed array</p>
<h2 class="class"><a name="Function">Function Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This is the built-in class for Functions</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Function_apply">function Function.apply(this,args)</a></li>
    <li><a href="#l_Function_call">function Function.call(this,params,...)</a></li>
    <li><a href="#l_Function_replaceWith">function Function.replaceWith(newFunc)</a></li>
  </ul>
  <h3 class="detail"><a name="l_Function_apply">function Function.apply</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Function.apply(this,args)</code></p>
  <h4>Description</h4>
   <p class="description">This executes the function with the supplied 'this' argument and parameters</p>
  <h4>Parameters</h4>
   <p class="param"><b> this</b> The value to use as the 'this' argument when executing the function</p>
   <p class="param"><b> args</b> Optional Array of Arguments</p>
  <h4>Returns</h4>
   <p class="return">The return value of executing this function</p>
  <h3 class="detail"><a name="l_Function_call">function Function.call</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Function.call(this,params,...)</code></p>
  <h4>Description</h4>
   <p class="description">This executes the function with the supplied 'this' argument and parameters</p>
  <h4>Parameters</h4>
   <p class="param"><b> this</b> The value to use as the 'this' argument when executing the function</p>
   <p class="param"><b> params, ...</b> Optional Parameters</p>
  <h4>Returns</h4>
   <p class="return">The return value of executing this function</p>
  <h3 class="detail"><a name="l_Function_replaceWith">function Function.replaceWith</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Function.replaceWith(newFunc)</code></p>
  <h4>Description</h4>
   <p class="description">This replaces the function with the one in the argument - while keeping the old function's scope. This allows inner functions to be edited, and is used when <a href="#l__global_edit">edit</a>() is called on an inner function.</p>
  <h4>Parameters</h4>
   <p class="param"><b> newFunc</b> The new function to replace this function with</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
<h2 class="class"><a name="Graphics">Graphics Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This class provides Graphics operations that can be applied to a surface.</p>
   <p class="description">Use Graphics.createXXX to create a graphics object that renders in the way you want.</p>
   <p class="description">NOTE: On boards that contain an LCD, there is a built-in 'LCD' object of type Graphics. For instance to draw a line you'd type: <code>LCD.drawLine(0,0,100,100)</code></p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Graphics_clear">function Graphics.clear()</a></li>
    <li><a href="#l_Graphics_createArrayBuffer">Graphics.createArrayBuffer(width,height,bpp,options)</a></li>
    <li><a href="#l_Graphics_createCallback">Graphics.createCallback(width,height,bpp,callback)</a></li>
    <li><a href="#l_Graphics_createSDL">Graphics.createSDL(width,height)</a></li>
    <li><a href="#l_Graphics_drawImage">function Graphics.drawImage(image,x,y)</a></li>
    <li><a href="#l_Graphics_drawLine">function Graphics.drawLine(x1,y1,x2,y2)</a></li>
    <li><a href="#l_Graphics_drawRect">function Graphics.drawRect(x1,y1,x2,y2)</a></li>
    <li><a href="#l_Graphics_drawString">function Graphics.drawString(str,x,y)</a></li>
    <li><a href="#l_Graphics_fillPoly">function Graphics.fillPoly(poly)</a></li>
    <li><a href="#l_Graphics_fillRect">function Graphics.fillRect(x1,y1,x2,y2)</a></li>
    <li><a href="#l_Graphics_getBgColor">function Graphics.getBgColor()</a></li>
    <li><a href="#l_Graphics_getColor">function Graphics.getColor()</a></li>
    <li><a href="#l_Graphics_getHeight">function Graphics.getHeight()</a></li>
    <li><a href="#l_Graphics_getPixel">function Graphics.getPixel(x,y)</a></li>
    <li><a href="#l_Graphics_getWidth">function Graphics.getWidth()</a></li>
    <li><a href="#l_Graphics_lineTo">function Graphics.lineTo(x,y)</a></li>
    <li><a href="#l_Graphics_moveTo">function Graphics.moveTo(x,y)</a></li>
    <li><a href="#l_Graphics_setBgColor">function Graphics.setBgColor(r,g,b)</a></li>
    <li><a href="#l_Graphics_setColor">function Graphics.setColor(r,g,b)</a></li>
    <li><a href="#l_Graphics_setFontBitmap">function Graphics.setFontBitmap()</a></li>
    <li><a href="#l_Graphics_setFontCustom">function Graphics.setFontCustom(bitmap,firstChar,width,height)</a></li>
    <li><a href="#l_Graphics_setFontVector">function Graphics.setFontVector(size)</a></li>
    <li><a href="#l_Graphics_setPixel">function Graphics.setPixel(x,y,col)</a></li>
    <li><a href="#l_Graphics_setRotation">function Graphics.setRotation(rotation,reflect)</a></li>
    <li><a href="#l_Graphics_stringWidth">function Graphics.stringWidth(str)</a></li>
  </ul>
  <h3 class="detail"><a name="l_Graphics_clear">function Graphics.clear</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.clear()</code></p>
  <h4>Description</h4>
   <p class="description">Clear the LCD with the Background Color</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Graphics_createArrayBuffer">Graphics.createArrayBuffer</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Graphics.createArrayBuffer(width,height,bpp,options)</code></p>
  <h4>Description</h4>
   <p class="description">Create a Graphics object that renders to an Array Buffer. This will have a field called 'buffer' that can get used to get at the buffer itself</p>
  <h4>Parameters</h4>
   <p class="param"><b> width</b> Pixels wide</p>
   <p class="param"><b> height</b> Pixels high</p>
   <p class="param"><b> bpp</b> Number of bits per pixel</p>
   <p class="param"><b> options</b> An object of other options. <code>{ zigzag : true/false(default), vertical_byte : true/false(default) }</code><br/>zigzag = whether to alternate the direction of scanlines for rows<br/>vertical_byte = whether to align bits in a byte vertically or not</p>
  <h4>Returns</h4>
   <p class="return">The new Graphics object</p>
  <h3 class="detail"><a name="l_Graphics_createCallback">Graphics.createCallback</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Graphics.createCallback(width,height,bpp,callback)</code></p>
  <h4>Description</h4>
   <p class="description">Create a Graphics object that renders by calling a JavaScript callback function to draw pixels</p>
  <h4>Parameters</h4>
   <p class="param"><b> width</b> Pixels wide</p>
   <p class="param"><b> height</b> Pixels high</p>
   <p class="param"><b> bpp</b> Number of bits per pixel</p>
   <p class="param"><b> callback</b> A function of the form <code>function(x,y,col)</code> that is called whenever a pixel needs to be drawn, or an object with: <code>{setPixel:function(x,y,col),fillRect:function(x1,y1,x2,y2,col)}</code>. All arguments are already bounds checked.</p>
  <h4>Returns</h4>
   <p class="return">The new Graphics object</p>
  <h3 class="detail"><a name="l_Graphics_createSDL">Graphics.createSDL</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Graphics.createSDL(width,height)</code></p>
  <h4>Description</h4>
   <p class="description">Create a Graphics object that renders to SDL window (Linux-based devices only)</p>
   <p class="description"><b>Note:</b> This is only available in some devices: Linux with SDL support compiled in</p>
  <h4>Parameters</h4>
   <p class="param"><b> width</b> Pixels wide</p>
   <p class="param"><b> height</b> Pixels high</p>
  <h4>Returns</h4>
   <p class="return">The new Graphics object</p>
  <h3 class="detail"><a name="l_Graphics_drawImage">function Graphics.drawImage</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.drawImage(image,x,y)</code></p>
  <h4>Description</h4>
   <p class="description">Draw an image at the specified position. If the image is 1 bit, the graphics foreground/background colours will be used. Otherwise color data will be copied as-is. Bitmaps are rendered MSB-first</p>
  <h4>Parameters</h4>
   <p class="param"><b> image</b> An object with the following fields <code>{ width : int, height : int, bpp : int, buffer : ArrayBuffer, transparent: optional int }</code>. bpp = bits per pixel, transparent (if defined) is the colour that will be treated as transparent</p>
   <p class="param"><b> x</b> The X offset to draw the image</p>
   <p class="param"><b> y</b> The Y offset to draw the image</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Graphics_drawLine">function Graphics.drawLine</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.drawLine(x1,y1,x2,y2)</code></p>
  <h4>Description</h4>
   <p class="description">Draw a line between x1,y1 and x2,y2 in the current foreground color</p>
  <h4>Parameters</h4>
   <p class="param"><b> x1</b> The left</p>
   <p class="param"><b> y1</b> The top</p>
   <p class="param"><b> x2</b> The right</p>
   <p class="param"><b> y2</b> The bottom</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Graphics_drawRect">function Graphics.drawRect</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.drawRect(x1,y1,x2,y2)</code></p>
  <h4>Description</h4>
   <p class="description">Draw an unfilled rectangle 1px wide in the Foreground Color</p>
  <h4>Parameters</h4>
   <p class="param"><b> x1</b> The left</p>
   <p class="param"><b> y1</b> The top</p>
   <p class="param"><b> x2</b> The right</p>
   <p class="param"><b> y2</b> The bottom</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Graphics_drawString">function Graphics.drawString</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.drawString(str,x,y)</code></p>
  <h4>Description</h4>
   <p class="description">Draw a string of text in the current font</p>
  <h4>Parameters</h4>
   <p class="param"><b> str</b> The string</p>
   <p class="param"><b> x</b> The left</p>
   <p class="param"><b> y</b> The top</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Graphics_fillPoly">function Graphics.fillPoly</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.fillPoly(poly)</code></p>
  <h4>Description</h4>
   <p class="description">Draw a filled polygon in the current foreground color</p>
  <h4>Parameters</h4>
   <p class="param"><b> poly</b> An array of vertices, of the form <code>[x1,y1,x2,y2,x3,y3,etc]</code></p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Graphics_fillRect">function Graphics.fillRect</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.fillRect(x1,y1,x2,y2)</code></p>
  <h4>Description</h4>
   <p class="description">Fill a rectangular area in the Foreground Color</p>
  <h4>Parameters</h4>
   <p class="param"><b> x1</b> The left</p>
   <p class="param"><b> y1</b> The top</p>
   <p class="param"><b> x2</b> The right</p>
   <p class="param"><b> y2</b> The bottom</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Graphics_getBgColor">function Graphics.getBgColor</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.getBgColor()</code></p>
  <h4>Description</h4>
   <p class="description">Get the background color to use for subsequent drawing operations</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The integer value of the colour</p>
  <h3 class="detail"><a name="l_Graphics_getColor">function Graphics.getColor</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.getColor()</code></p>
  <h4>Description</h4>
   <p class="description">Get the color to use for subsequent drawing operations</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The integer value of the colour</p>
  <h3 class="detail"><a name="l_Graphics_getHeight">function Graphics.getHeight</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.getHeight()</code></p>
  <h4>Description</h4>
   <p class="description">The height of the LCD</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The height of the LCD</p>
  <h3 class="detail"><a name="l_Graphics_getPixel">function Graphics.getPixel</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.getPixel(x,y)</code></p>
  <h4>Description</h4>
   <p class="description">Get a pixel's color</p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> The left</p>
   <p class="param"><b> y</b> The top</p>
  <h4>Returns</h4>
   <p class="return">The color</p>
  <h3 class="detail"><a name="l_Graphics_getWidth">function Graphics.getWidth</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.getWidth()</code></p>
  <h4>Description</h4>
   <p class="description">The width of the LCD</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The width of the LCD</p>
  <h3 class="detail"><a name="l_Graphics_lineTo">function Graphics.lineTo</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.lineTo(x,y)</code></p>
  <h4>Description</h4>
   <p class="description">Draw a line from the last position of lineTo or moveTo to this position</p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> X value</p>
   <p class="param"><b> y</b> Y value</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Graphics_moveTo">function Graphics.moveTo</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.moveTo(x,y)</code></p>
  <h4>Description</h4>
   <p class="description">Move the cursor to a position - see lineTo</p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> X value</p>
   <p class="param"><b> y</b> Y value</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Graphics_setBgColor">function Graphics.setBgColor</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.setBgColor(r,g,b)</code></p>
  <h4>Description</h4>
   <p class="description">Set the background color to use for subsequent drawing operations</p>
  <h4>Parameters</h4>
   <p class="param"><b> r</b> Red (between 0 and 1) OR an integer representing the color in the current bit depth</p>
   <p class="param"><b> g</b> Green (between 0 and 1)</p>
   <p class="param"><b> b</b> Blue (between 0 and 1)</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Graphics_setColor">function Graphics.setColor</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.setColor(r,g,b)</code></p>
  <h4>Description</h4>
   <p class="description">Set the color to use for subsequent drawing operations</p>
  <h4>Parameters</h4>
   <p class="param"><b> r</b> Red (between 0 and 1) OR an integer representing the color in the current bit depth</p>
   <p class="param"><b> g</b> Green (between 0 and 1)</p>
   <p class="param"><b> b</b> Blue (between 0 and 1)</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Graphics_setFontBitmap">function Graphics.setFontBitmap</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.setFontBitmap()</code></p>
  <h4>Description</h4>
   <p class="description">Set Graphics to draw with a Bitmapped Font</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Graphics_setFontCustom">function Graphics.setFontCustom</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.setFontCustom(bitmap,firstChar,width,height)</code></p>
  <h4>Description</h4>
   <p class="description">Set Graphics to draw with a Custom Font</p>
  <h4>Parameters</h4>
   <p class="param"><b> bitmap</b> A column-first, MSB-first, 1bpp bitmap containing the font bitmap</p>
   <p class="param"><b> firstChar</b> The first character in the font - usually 32 (space)</p>
   <p class="param"><b> width</b> The width of each character in the font. Either an integer, or a string where each character represents the width</p>
   <p class="param"><b> height</b> The height as an integer</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Graphics_setFontVector">function Graphics.setFontVector</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.setFontVector(size)</code></p>
  <h4>Description</h4>
   <p class="description">Set Graphics to draw with a Vector Font of the given size</p>
  <h4>Parameters</h4>
   <p class="param"><b> size</b> The size as an integer</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Graphics_setPixel">function Graphics.setPixel</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.setPixel(x,y,col)</code></p>
  <h4>Description</h4>
   <p class="description">Set a pixel's color</p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> The left</p>
   <p class="param"><b> y</b> The top</p>
   <p class="param"><b> col</b> The color</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Graphics_setRotation">function Graphics.setRotation</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.setRotation(rotation,reflect)</code></p>
  <h4>Description</h4>
   <p class="description">Set the current rotation of the graphics device.</p>
  <h4>Parameters</h4>
   <p class="param"><b> rotation</b> The clockwise rotation. 0 for no rotation, 1 for 90 degrees, 2 for 180, 3 for 270</p>
   <p class="param"><b> reflect</b> Whether to reflect the image</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Graphics_stringWidth">function Graphics.stringWidth</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Graphics.stringWidth(str)</code></p>
  <h4>Description</h4>
   <p class="description">Return the size in pixels of a string of text in the current font</p>
  <h4>Parameters</h4>
   <p class="param"><b> str</b> The string</p>
  <h4>Returns</h4>
   <p class="return">The length of the string in pixels</p>
<h2 class="class"><a name="I2C">I2C Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This class allows use of the built-in I2C ports. Currently it allows I2C Master mode only.</p>
   <p class="description">All addresses are in 7 bit format. If you have an 8 bit address then you need to shift it one bit to the right.</p>
  <h4>Instances</h4>
  <ul>
    <li><p class="instance">I2C1</p>
   <p class="description">The first I2C port</p>
    </li>
    <li><p class="instance">I2C2</p>
   <p class="description">The second I2C port</p>
    </li>
    <li><p class="instance">I2C3</p>
   <p class="description">The third I2C port</p>
    </li>
  </ul>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_I2C_readFrom">function I2C.readFrom(address,quantity)</a></li>
    <li><a href="#l_I2C_setup">function I2C.setup(options)</a></li>
    <li><a href="#l_I2C_writeTo">function I2C.writeTo(address,data,...)</a></li>
  </ul>
  <h3 class="detail"><a name="l_I2C_readFrom">function I2C.readFrom</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function I2C.readFrom(address,quantity)</code></p>
  <h4>Description</h4>
   <p class="description">Request bytes from the given slave device, and return them as an array. This is like using Arduino Wire's requestFrom, available and read functions.  Sends a STOP</p>
  <h4>Parameters</h4>
   <p class="param"><b> address</b> The 7 bit address of the device to request bytes from</p>
   <p class="param"><b> quantity</b> The number of bytes to request</p>
  <h4>Returns</h4>
   <p class="return">The data that was returned - an array of bytes</p>
  <h3 class="detail"><a name="l_I2C_setup">function I2C.setup</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function I2C.setup(options)</code></p>
  <h4>Description</h4>
   <p class="description">Set up this I2C port</p>
   <p class="description">If not specified in options, the default pins are used (usually the lowest numbered pins on the lowest port that supports this peripheral)</p>
  <h4>Parameters</h4>
   <p class="param"><b> options</b> An optional structure containing extra information on initialising the I2C port<br/><code>{scl:pin, sda:pin}</code><br/>You can find out which pins to use by looking at <a href="#boards">your board's reference page</a> and searching for pins with the <code>I2C</code> marker.</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_I2C_writeTo">function I2C.writeTo</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function I2C.writeTo(address,data,...)</code></p>
  <h4>Description</h4>
   <p class="description">Transmit to the slave device with the given address. This is like Arduino's beginTransmission, write, and endTransmission rolled up into one.</p>
  <h4>Parameters</h4>
   <p class="param"><b> address</b> The 7 bit address of the device to transmit to</p>
   <p class="param"><b> data, ...</b> One or more items to write. May be ints, strings, arrays, or objects of the form <code>{data: ..., count:#}</code>.</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
<h2 class="class"><a name="Int16Array">Int16Array Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This is the built-in JavaScript class for a typed array.</p>
   <p class="description">Instantiate this in order to efficiently store arrays of data (Espruino's normal arrays store data in a map, which is inefficient for non-sparse arrays). </p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Int16Array_Int16Array">constructor Int16Array(arr,byteOffset,length)</a></li>
  </ul>
  <h3 class="detail"><a name="l_Int16Array_Int16Array">constructor Int16Array</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>constructor Int16Array(arr,byteOffset,length)</code></p>
  <h4>Description</h4>
   <p class="description">Create a typed array based on the given input. Either an existing Array Buffer, an Integer as a Length, or a simple array. If an ArrayBuffer view (eg. Uint8Array rather than ArrayBuffer) is given, it will be completely copied rather than referenced.</p>
  <h4>Parameters</h4>
   <p class="param"><b> arr</b> The array or typed array to base this off, or an integer which is the array length</p>
   <p class="param"><b> byteOffset</b> The byte offset in the ArrayBuffer  (ONLY IF the first argument was an ArrayBuffer)</p>
   <p class="param"><b> length</b> The length (ONLY IF the first argument was an ArrayBuffer)</p>
  <h4>Returns</h4>
   <p class="return">A typed array</p>
<h2 class="class"><a name="Int32Array">Int32Array Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This is the built-in JavaScript class for a typed array.</p>
   <p class="description">Instantiate this in order to efficiently store arrays of data (Espruino's normal arrays store data in a map, which is inefficient for non-sparse arrays). </p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Int32Array_Int32Array">constructor Int32Array(arr,byteOffset,length)</a></li>
  </ul>
  <h3 class="detail"><a name="l_Int32Array_Int32Array">constructor Int32Array</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>constructor Int32Array(arr,byteOffset,length)</code></p>
  <h4>Description</h4>
   <p class="description">Create a typed array based on the given input. Either an existing Array Buffer, an Integer as a Length, or a simple array. If an ArrayBuffer view (eg. Uint8Array rather than ArrayBuffer) is given, it will be completely copied rather than referenced.</p>
  <h4>Parameters</h4>
   <p class="param"><b> arr</b> The array or typed array to base this off, or an integer which is the array length</p>
   <p class="param"><b> byteOffset</b> The byte offset in the ArrayBuffer  (ONLY IF the first argument was an ArrayBuffer)</p>
   <p class="param"><b> length</b> The length (ONLY IF the first argument was an ArrayBuffer)</p>
  <h4>Returns</h4>
   <p class="return">A typed array</p>
<h2 class="class"><a name="Int8Array">Int8Array Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This is the built-in JavaScript class for a typed array.</p>
   <p class="description">Instantiate this in order to efficiently store arrays of data (Espruino's normal arrays store data in a map, which is inefficient for non-sparse arrays). </p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Int8Array_Int8Array">constructor Int8Array(arr,byteOffset,length)</a></li>
  </ul>
  <h3 class="detail"><a name="l_Int8Array_Int8Array">constructor Int8Array</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>constructor Int8Array(arr,byteOffset,length)</code></p>
  <h4>Description</h4>
   <p class="description">Create a typed array based on the given input. Either an existing Array Buffer, an Integer as a Length, or a simple array. If an ArrayBuffer view (eg. Uint8Array rather than ArrayBuffer) is given, it will be completely copied rather than referenced.</p>
  <h4>Parameters</h4>
   <p class="param"><b> arr</b> The array or typed array to base this off, or an integer which is the array length</p>
   <p class="param"><b> byteOffset</b> The byte offset in the ArrayBuffer  (ONLY IF the first argument was an ArrayBuffer)</p>
   <p class="param"><b> length</b> The length (ONLY IF the first argument was an ArrayBuffer)</p>
  <h4>Returns</h4>
   <p class="return">A typed array</p>
<h2 class="class"><a name="JSON">JSON Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_JSON_parse">JSON.parse(string)</a></li>
    <li><a href="#l_JSON_stringify">JSON.stringify(data)</a></li>
  </ul>
  <h3 class="detail"><a name="l_JSON_parse">JSON.parse</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>JSON.parse(string)</code></p>
  <h4>Description</h4>
   <p class="description">Parse the given JSON string into a JavaScript object</p>
   <p class="description">NOTE: This implementation uses <a href="#l__global_eval">eval</a>() internally, and as such it is unsafe as it can allow arbitrary JS commands to be executed.</p>
  <h4>Parameters</h4>
   <p class="param"><b> string</b> A JSON string</p>
  <h4>Returns</h4>
   <p class="return">The JavaScript object created by parsing the data string</p>
  <h3 class="detail"><a name="l_JSON_stringify">JSON.stringify</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>JSON.stringify(data)</code></p>
  <h4>Description</h4>
   <p class="description">Convert the given object into a JSON string which can subsequently be parsed with <a href="#l_JSON_parse">JSON.parse</a> or eval</p>
  <h4>Parameters</h4>
   <p class="param"><b> data</b> The data to be converted to a JSON string</p>
  <h4>Returns</h4>
   <p class="return">A JSON string</p>
<h2 class="class"><a name="Math">Math Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This is a standard JavaScript class that contains useful Maths routines</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Math_E">Math.E</a></li>
    <li><a href="#l_Math_LN10">Math.LN10</a></li>
    <li><a href="#l_Math_LN2">Math.LN2</a></li>
    <li><a href="#l_Math_LOG10E">Math.LOG10E</a></li>
    <li><a href="#l_Math_LOG2E">Math.LOG2E</a></li>
    <li><a href="#l_Math_PI">Math.PI</a></li>
    <li><a href="#l_Math_SQRT1_2">Math.SQRT1_2</a></li>
    <li><a href="#l_Math_SQRT2">Math.SQRT2</a></li>
    <li><a href="#l_Math_abs">Math.abs(x)</a></li>
    <li><a href="#l_Math_acos">Math.acos(x)</a></li>
    <li><a href="#l_Math_asin">Math.asin(x)</a></li>
    <li><a href="#l_Math_atan">Math.atan(x)</a></li>
    <li><a href="#l_Math_atan2">Math.atan2(y,x)</a></li>
    <li><a href="#l_Math_ceil">Math.ceil(x)</a></li>
    <li><a href="#l_Math_clip">Math.clip(x,min,max)</a></li>
    <li><a href="#l_Math_cos">Math.cos(theta)</a></li>
    <li><a href="#l_Math_exp">Math.exp(x)</a></li>
    <li><a href="#l_Math_floor">Math.floor(x)</a></li>
    <li><a href="#l_Math_log">Math.log(x)</a></li>
    <li><a href="#l_Math_max">Math.max(args,...)</a></li>
    <li><a href="#l_Math_min">Math.min(args,...)</a></li>
    <li><a href="#l_Math_pow">Math.pow(x,y)</a></li>
    <li><a href="#l_Math_random">Math.random()</a></li>
    <li><a href="#l_Math_round">Math.round(x)</a></li>
    <li><a href="#l_Math_sin">Math.sin(theta)</a></li>
    <li><a href="#l_Math_sqrt">Math.sqrt(x)</a></li>
    <li><a href="#l_Math_tan">Math.tan(theta)</a></li>
    <li><a href="#l_Math_wrap">Math.wrap(x,max)</a></li>
  </ul>
  <h3 class="detail"><a name="l_Math_E">Math.E</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.E</code></p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The value of E - 2.718281828459045</p>
  <h3 class="detail"><a name="l_Math_LN10">Math.LN10</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.LN10</code></p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The natural logarithm of 10 - 2.302585092994046</p>
  <h3 class="detail"><a name="l_Math_LN2">Math.LN2</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.LN2</code></p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The natural logarithm of 2 - 0.6931471805599453</p>
  <h3 class="detail"><a name="l_Math_LOG10E">Math.LOG10E</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.LOG10E</code></p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The base 10 logarithm of e - 0.4342944819032518</p>
  <h3 class="detail"><a name="l_Math_LOG2E">Math.LOG2E</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.LOG2E</code></p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The base 2 logarithm of e - 1.4426950408889634</p>
  <h3 class="detail"><a name="l_Math_PI">Math.PI</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.PI</code></p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The value of PI - 3.141592653589793</p>
  <h3 class="detail"><a name="l_Math_SQRT1_2">Math.SQRT1_2</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.SQRT1_2</code></p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The square root of 1/2 - 0.7071067811865476</p>
  <h3 class="detail"><a name="l_Math_SQRT2">Math.SQRT2</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.SQRT2</code></p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The square root of 2 - 1.4142135623730951</p>
  <h3 class="detail"><a name="l_Math_abs">Math.abs</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.abs(x)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> A floating point value</p>
  <h4>Returns</h4>
   <p class="return">The absolute value of x (eg, <code>Math.abs(2)==2</code>, but also <code>Math.abs(-2)==2</code>)</p>
  <h3 class="detail"><a name="l_Math_acos">Math.acos</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.acos(x)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> The value to get the arc cosine of</p>
  <h4>Returns</h4>
   <p class="return">The arc cosine of x, between 0 and PI</p>
  <h3 class="detail"><a name="l_Math_asin">Math.asin</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.asin(x)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> The value to get the arc sine of</p>
  <h4>Returns</h4>
   <p class="return">The arc sine of x, between -PI/2 and PI/2</p>
  <h3 class="detail"><a name="l_Math_atan">Math.atan</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.atan(x)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> The value to get the arc tangent  of</p>
  <h4>Returns</h4>
   <p class="return">The arc tangent of x, between -PI/2 and PI/2</p>
  <h3 class="detail"><a name="l_Math_atan2">Math.atan2</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.atan2(y,x)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> y</b> The Y-part of the angle to get the arc tangent of</p>
   <p class="param"><b> x</b> The X-part of the angle to get the arc tangent of</p>
  <h4>Returns</h4>
   <p class="return">The arctangent of Y/X, between -PI and PI</p>
  <h3 class="detail"><a name="l_Math_ceil">Math.ceil</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.ceil(x)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> The value to round up</p>
  <h4>Returns</h4>
   <p class="return">x, rounded upwards to the nearest integer</p>
  <h3 class="detail"><a name="l_Math_clip">Math.clip</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.clip(x,min,max)</code></p>
  <h4>Description</h4>
   <p class="description">DEPRECATED - Please use <code>E.clip()</code> instead. Clip a number to be between min and max (inclusive)</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> A floating point value to clip</p>
   <p class="param"><b> min</b> The smallest the value should be</p>
   <p class="param"><b> max</b> The largest the value should be</p>
  <h4>Returns</h4>
   <p class="return">The value of x, clipped so as not to be below min or above max.</p>
  <h3 class="detail"><a name="l_Math_cos">Math.cos</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.cos(theta)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> theta</b> The angle to get the cosine of</p>
  <h4>Returns</h4>
   <p class="return">The cosine of theta</p>
  <h3 class="detail"><a name="l_Math_exp">Math.exp</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.exp(x)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> The value raise E to the power of</p>
  <h4>Returns</h4>
   <p class="return">E^x</p>
  <h3 class="detail"><a name="l_Math_floor">Math.floor</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.floor(x)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> The value to round down</p>
  <h4>Returns</h4>
   <p class="return">x, rounded downwards to the nearest integer</p>
  <h3 class="detail"><a name="l_Math_log">Math.log</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.log(x)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> The value to take the logarithm (base E) root of</p>
  <h4>Returns</h4>
   <p class="return">The log (base E) of x</p>
  <h3 class="detail"><a name="l_Math_max">Math.max</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.max(args,...)</code></p>
  <h4>Description</h4>
   <p class="description">Find the maximum of a series of numbers</p>
  <h4>Parameters</h4>
   <p class="param"><b> args, ...</b> A floating point value to clip</p>
  <h4>Returns</h4>
   <p class="return">The maximum of the supplied values</p>
  <h3 class="detail"><a name="l_Math_min">Math.min</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.min(args,...)</code></p>
  <h4>Description</h4>
   <p class="description">Find the minimum of a series of numbers</p>
  <h4>Parameters</h4>
   <p class="param"><b> args, ...</b> A floating point value to clip</p>
  <h4>Returns</h4>
   <p class="return">The minimum of the supplied values</p>
  <h3 class="detail"><a name="l_Math_pow">Math.pow</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.pow(x,y)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> The value to raise to the power</p>
   <p class="param"><b> y</b> The power x should be raised to</p>
  <h4>Returns</h4>
   <p class="return">x raised to the power y (x^y)</p>
  <h3 class="detail"><a name="l_Math_random">Math.random</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.random()</code></p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">A random number between 0 and 1</p>
  <h3 class="detail"><a name="l_Math_round">Math.round</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.round(x)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> The value to round</p>
  <h4>Returns</h4>
   <p class="return">x, rounded to the nearest integer</p>
  <h3 class="detail"><a name="l_Math_sin">Math.sin</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.sin(theta)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> theta</b> The angle to get the sine of</p>
  <h4>Returns</h4>
   <p class="return">The sine of theta</p>
  <h3 class="detail"><a name="l_Math_sqrt">Math.sqrt</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.sqrt(x)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> The value to take the square root of</p>
  <h4>Returns</h4>
   <p class="return">The square root of x</p>
  <h3 class="detail"><a name="l_Math_tan">Math.tan</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.tan(theta)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> theta</b> The angle to get the tangent of</p>
  <h4>Returns</h4>
   <p class="return">The tangent of theta</p>
  <h3 class="detail"><a name="l_Math_wrap">Math.wrap</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Math.wrap(x,max)</code></p>
  <h4>Description</h4>
   <p class="description">Wrap a number around if it is less than 0 or greater than or equal to max. For instance you might do: <code>Math.wrap(angleInDegrees, 360)</code></p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> x</b> A floating point value to wrap</p>
   <p class="param"><b> max</b> The largest the value should be</p>
  <h4>Returns</h4>
   <p class="return">The value of x, wrapped so as not to be below min or above max.</p>
<h2 class="class"><a name="Modules">Modules Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Modules_addCached">Modules.addCached(id,sourcecode)</a></li>
    <li><a href="#l_Modules_getCached">Modules.getCached()</a></li>
    <li><a href="#l_Modules_removeAllCached">Modules.removeAllCached()</a></li>
    <li><a href="#l_Modules_removeCached">Modules.removeCached(id)</a></li>
  </ul>
  <h3 class="detail"><a name="l_Modules_addCached">Modules.addCached</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Modules.addCached(id,sourcecode)</code></p>
  <h4>Description</h4>
   <p class="description">Add the given module to the cache</p>
  <h4>Parameters</h4>
   <p class="param"><b> id</b> The module name to add</p>
   <p class="param"><b> sourcecode</b> The module's sourcecode</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Modules_getCached">Modules.getCached</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Modules.getCached()</code></p>
  <h4>Description</h4>
   <p class="description">Return an array of module names that have been cached</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">An array of module names</p>
  <h3 class="detail"><a name="l_Modules_removeAllCached">Modules.removeAllCached</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Modules.removeAllCached()</code></p>
  <h4>Description</h4>
   <p class="description">Remove all cached modules</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Modules_removeCached">Modules.removeCached</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Modules.removeCached(id)</code></p>
  <h4>Description</h4>
   <p class="description">Remove the given module from the list of cached modules</p>
  <h4>Parameters</h4>
   <p class="param"><b> id</b> The module name to remove</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
<h2 class="class"><a name="Number">Number Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This is the built-in JavaScript class for numbers.</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Number_MAX_VALUE">Number.MAX_VALUE</a></li>
    <li><a href="#l_Number_MIN_VALUE">Number.MIN_VALUE</a></li>
    <li><a href="#l_Number_NEGATIVE_INFINITY">Number.NEGATIVE_INFINITY</a></li>
    <li><a href="#l_Number_NaN">Number.NaN</a></li>
    <li><a href="#l_Number_Number">constructor Number(value)</a></li>
    <li><a href="#l_Number_POSITIVE_INFINITY">Number.POSITIVE_INFINITY</a></li>
    <li><a href="#l_Number_toFixed">function Number.toFixed(decimalPlaces)</a></li>
  </ul>
  <h3 class="detail"><a name="l_Number_MAX_VALUE">Number.MAX_VALUE</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Number.MAX_VALUE</code></p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">Maximum representable value</p>
  <h3 class="detail"><a name="l_Number_MIN_VALUE">Number.MIN_VALUE</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Number.MIN_VALUE</code></p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">Smallest representable value</p>
  <h3 class="detail"><a name="l_Number_NEGATIVE_INFINITY">Number.NEGATIVE_INFINITY</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Number.NEGATIVE_INFINITY</code></p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">Negative Infinity (-1/0)</p>
  <h3 class="detail"><a name="l_Number_NaN">Number.NaN</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Number.NaN</code></p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">Not a  Number</p>
  <h3 class="detail"><a name="l_Number_Number">constructor Number</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>constructor Number(value)</code></p>
  <h4>Description</h4>
   <p class="description">Creates a number</p>
  <h4>Parameters</h4>
   <p class="param"><b> value</b> A value to be converted to a number</p>
  <h4>Returns</h4>
   <p class="return">A Number object</p>
  <h3 class="detail"><a name="l_Number_POSITIVE_INFINITY">Number.POSITIVE_INFINITY</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Number.POSITIVE_INFINITY</code></p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">Positive Infinity (1/0)</p>
  <h3 class="detail"><a name="l_Number_toFixed">function Number.toFixed</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Number.toFixed(decimalPlaces)</code></p>
  <h4>Description</h4>
   <p class="description">Format the number as a fixed point number</p>
  <h4>Parameters</h4>
   <p class="param"><b> decimalPlaces</b> A number between 0 and 20 specifying the number of decimal digits after the decimal point</p>
  <h4>Returns</h4>
   <p class="return">A string</p>
<h2 class="class"><a name="Object">Object Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This is the built-in class for Objects</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Object_clone">function Object.clone()</a></li>
    <li><a href="#l_Object_emit">function Object.emit(event,args,...)</a></li>
    <li><a href="#l_Object_getOwnPropertyNames">Object.getOwnPropertyNames(object)</a></li>
    <li><a href="#l_Object_hasOwnProperty">function Object.hasOwnProperty(name)</a></li>
    <li><a href="#l_Object_keys">Object.keys(object)</a></li>
    <li><a href="#l_Object_length">property Object.length</a></li>
    <li><a href="#l_Object_on">function Object.on(event,listener)</a></li>
    <li><a href="#l_Object_removeAllListeners">function Object.removeAllListeners(event)</a></li>
    <li><a href="#l_Object_toString">function Object.toString(radix)</a></li>
    <li><a href="#l_Object_valueOf">function Object.valueOf()</a></li>
  </ul>
  <h3 class="detail"><a name="l_Object_clone">function Object.clone</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Object.clone()</code></p>
  <h4>Description</h4>
   <p class="description">Copy this object completely</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">A copy of this Object</p>
  <h3 class="detail"><a name="l_Object_emit">function Object.emit</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Object.emit(event,args,...)</code></p>
  <h4>Description</h4>
   <p class="description">Call the event listeners for this object, for instance <code>http.emit('data', 'Foo')</code>. See Node.js's EventEmitter.</p>
  <h4>Parameters</h4>
   <p class="param"><b> event</b> The name of the event, for instance 'data'</p>
   <p class="param"><b> args, ...</b> Optional arguments</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Object_getOwnPropertyNames">Object.getOwnPropertyNames</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Object.getOwnPropertyNames(object)</code></p>
  <h4>Description</h4>
   <p class="description">Returns an array of all properties (enumerable or not) found directly on a given object.</p>
   <p class="description">**Note:** This doesn't currently work as it should for built-in objects and their prototypes. See bug #380</p>
  <h4>Parameters</h4>
   <p class="param"><b> object</b> The Object to return a list of property names for</p>
  <h4>Returns</h4>
   <p class="return">An array of the Object's own properties</p>
  <h3 class="detail"><a name="l_Object_hasOwnProperty">function Object.hasOwnProperty</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Object.hasOwnProperty(name)</code></p>
  <h4>Description</h4>
   <p class="description">Return true if the object (not its prototype) has the given property.</p>
   <p class="description">NOTE: This currently returns false-positives for built-in functions in prototypes</p>
  <h4>Parameters</h4>
   <p class="param"><b> name</b> The name of the property to search for</p>
  <h4>Returns</h4>
   <p class="return">True if it exists, false if it doesn't</p>
  <h3 class="detail"><a name="l_Object_keys">Object.keys</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Object.keys(object)</code></p>
  <h4>Description</h4>
   <p class="description">Return all enumerable keys of the given object</p>
  <h4>Parameters</h4>
   <p class="param"><b> object</b> The object to return keys for</p>
  <h4>Returns</h4>
   <p class="return">An array of strings - one for each key on the given object</p>
  <h3 class="detail"><a name="l_Object_length">property Object.length</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>property Object.length</code></p>
  <h4>Description</h4>
   <p class="description">Find the length of the object</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The length of the object</p>
  <h3 class="detail"><a name="l_Object_on">function Object.on</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Object.on(event,listener)</code></p>
  <h4>Description</h4>
   <p class="description">Register an event listener for this object, for instance <code>http.on('data', function(d) {...})</code>. See Node.js's EventEmitter.</p>
  <h4>Parameters</h4>
   <p class="param"><b> event</b> The name of the event, for instance 'data'</p>
   <p class="param"><b> listener</b> The listener to call when this event is received</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Object_removeAllListeners">function Object.removeAllListeners</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Object.removeAllListeners(event)</code></p>
  <h4>Description</h4>
   <p class="description">Removes all listeners, or those of the specified event.</p>
  <h4>Parameters</h4>
   <p class="param"><b> event</b> The name of the event, for instance 'data'</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Object_toString">function Object.toString</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Object.toString(radix)</code></p>
  <h4>Description</h4>
   <p class="description">Convert the Object to a string</p>
  <h4>Parameters</h4>
   <p class="param"><b> radix</b> If the object is an integer, the radix (between 2 and 36) to use. NOTE: Setting a radix does not work on floating point numbers.</p>
  <h4>Returns</h4>
   <p class="return">A String representing the object</p>
  <h3 class="detail"><a name="l_Object_valueOf">function Object.valueOf</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Object.valueOf()</code></p>
  <h4>Description</h4>
   <p class="description">Returns the primitive value of this object.</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The primitive value of this object</p>
<h2 class="class"><a name="OneWire">OneWire Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This class provides a software-defined OneWire master. It is designed to be similar to Arduino's OneWire library.</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_OneWire_OneWire">constructor OneWire(pin)</a></li>
    <li><a href="#l_OneWire_read">function OneWire.read()</a></li>
    <li><a href="#l_OneWire_reset">function OneWire.reset()</a></li>
    <li><a href="#l_OneWire_search">function OneWire.search()</a></li>
    <li><a href="#l_OneWire_select">function OneWire.select(rom)</a></li>
    <li><a href="#l_OneWire_skip">function OneWire.skip()</a></li>
    <li><a href="#l_OneWire_write">function OneWire.write(data,power)</a></li>
  </ul>
  <h3 class="detail"><a name="l_OneWire_OneWire">constructor OneWire</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>constructor OneWire(pin)</code></p>
  <h4>Description</h4>
   <p class="description">Create a software OneWire implementation on the given pin</p>
  <h4>Parameters</h4>
   <p class="param"><b> pin</b> The pin to implement OneWire on</p>
  <h4>Returns</h4>
   <p class="return">A OneWire object</p>
  <h3 class="detail"><a name="l_OneWire_read">function OneWire.read</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function OneWire.read()</code></p>
  <h4>Description</h4>
   <p class="description">Read a byte</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The byte that was read</p>
  <h3 class="detail"><a name="l_OneWire_reset">function OneWire.reset</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function OneWire.reset()</code></p>
  <h4>Description</h4>
   <p class="description">Perform a reset cycle</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">True is a device was present (it held the bus low)</p>
  <h3 class="detail"><a name="l_OneWire_search">function OneWire.search</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function OneWire.search()</code></p>
  <h4>Description</h4>
   <p class="description">Search for devices</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">An array of devices that were found</p>
  <h3 class="detail"><a name="l_OneWire_select">function OneWire.select</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function OneWire.select(rom)</code></p>
  <h4>Description</h4>
   <p class="description">Select a ROM - <a href="#l__global_reset">reset</a> needs to be done first</p>
  <h4>Parameters</h4>
   <p class="param"><b> rom</b> The device to select (get this using <code>OneWire.search()</code>)</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_OneWire_skip">function OneWire.skip</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function OneWire.skip()</code></p>
  <h4>Description</h4>
   <p class="description">Skip a ROM</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_OneWire_write">function OneWire.write</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function OneWire.write(data,power)</code></p>
  <h4>Description</h4>
   <p class="description">Write a byte</p>
  <h4>Parameters</h4>
   <p class="param"><b> data</b> A byte to write</p>
   <p class="param"><b> power</b> Whether to leave power on after write (default is false)</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
<h2 class="class"><a name="Pin">Pin Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This is the built-in class for Pins, such as D0,D1,LED1, or BTN</p>
   <p class="description">You can call the methods on Pin, or you can use Wiring-style functions such as digitalWrite</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Pin_Pin">constructor Pin(value)</a></li>
    <li><a href="#l_Pin_read">function Pin.read()</a></li>
    <li><a href="#l_Pin_reset">function Pin.reset()</a></li>
    <li><a href="#l_Pin_set">function Pin.set()</a></li>
    <li><a href="#l_Pin_write">function Pin.write(value)</a></li>
    <li><a href="#l_Pin_writeAtTime">function Pin.writeAtTime(value,time)</a></li>
  </ul>
  <h3 class="detail"><a name="l_Pin_Pin">constructor Pin</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>constructor Pin(value)</code></p>
  <h4>Description</h4>
   <p class="description">Creates a pin from the given argument (or returns undefined if no argument)</p>
  <h4>Parameters</h4>
   <p class="param"><b> value</b> A value to be converted to a pin. Can be a number, pin, or String.</p>
  <h4>Returns</h4>
   <p class="return">A Pin object</p>
  <h3 class="detail"><a name="l_Pin_read">function Pin.read</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Pin.read()</code></p>
  <h4>Description</h4>
   <p class="description">Returns the input state of the pin as a boolean</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">Whether pin is a logical 1 or 0</p>
  <h3 class="detail"><a name="l_Pin_reset">function Pin.reset</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Pin.reset()</code></p>
  <h4>Description</h4>
   <p class="description">Sets the output state of the pin to a 0</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Pin_set">function Pin.set</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Pin.set()</code></p>
  <h4>Description</h4>
   <p class="description">Sets the output state of the pin to a 1</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Pin_write">function Pin.write</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Pin.write(value)</code></p>
  <h4>Description</h4>
   <p class="description">Sets the output state of the pin to the parameter given</p>
  <h4>Parameters</h4>
   <p class="param"><b> value</b> Whether to set output high (true/1) or low (false/0)</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Pin_writeAtTime">function Pin.writeAtTime</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Pin.writeAtTime(value,time)</code></p>
  <h4>Description</h4>
   <p class="description">Sets the output state of the pin to the parameter given at the specified time</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> value</b> Whether to set output high (true/1) or low (false/0)</p>
   <p class="param"><b> time</b> Time at which to write</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
<h2 class="class"><a name="SPI">SPI Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This class allows use of the built-in SPI ports. Currently it is SPI master only.</p>
  <h4>Instances</h4>
  <ul>
    <li><p class="instance">SPI1</p>
   <p class="description">The first SPI port</p>
    </li>
    <li><p class="instance">SPI2</p>
   <p class="description">The second SPI port</p>
    </li>
    <li><p class="instance">SPI3</p>
   <p class="description">The third SPI port</p>
    </li>
  </ul>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_SPI_SPI">constructor SPI()</a></li>
    <li><a href="#l_SPI_send">function SPI.send(data,nss_pin)</a></li>
    <li><a href="#l_SPI_send4bit">function SPI.send4bit(data,bit0,bit1,nss_pin)</a></li>
    <li><a href="#l_SPI_send8bit">function SPI.send8bit(data,bit0,bit1,nss_pin)</a></li>
    <li><a href="#l_SPI_setup">function SPI.setup(options)</a></li>
    <li><a href="#l_SPI_write">function SPI.write(data,...)</a></li>
  </ul>
  <h3 class="detail"><a name="l_SPI_SPI">constructor SPI</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>constructor SPI()</code></p>
  <h4>Description</h4>
   <p class="description">Create a software SPI port. This has limited functionality (no baud rate), but it can work on any pins.</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_SPI_send">function SPI.send</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function SPI.send(data,nss_pin)</code></p>
  <h4>Description</h4>
   <p class="description">Send data down SPI, and return the result</p>
   <p class="description">Sending multiple bytes in one call to send is preferable as they can then be transmitted end to end. Using multiple calls to send() will result in significantly slower transmission speeds.</p>
  <h4>Parameters</h4>
   <p class="param"><b> data</b> The data to send - either an integer, array, or string (which is the most efficient)</p>
   <p class="param"><b> nss_pin</b> An nSS pin - this will be lowered before SPI output and raised afterwards (optional). There will be a small delay between when this is lowered and when sending starts, and also between sending finishing and it being raised.</p>
  <h4>Returns</h4>
   <p class="return">The data that was returned</p>
  <h3 class="detail"><a name="l_SPI_send4bit">function SPI.send4bit</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function SPI.send4bit(data,bit0,bit1,nss_pin)</code></p>
  <h4>Description</h4>
   <p class="description">Send data down SPI, using 4 bits for each 'real' bit (MSB first). This can be useful for faking one-wire style protocols</p>
   <p class="description">Sending multiple bytes in one call to send is preferable as they can then be transmitted end to end. Using multiple calls to send() will result in significantly slower transmission speeds.</p>
  <h4>Parameters</h4>
   <p class="param"><b> data</b> The data to send - either an integer, array, or string</p>
   <p class="param"><b> bit0</b> The 4 bits to send for a 0 (MSB first)</p>
   <p class="param"><b> bit1</b> The 4 bits to send for a 1 (MSB first)</p>
   <p class="param"><b> nss_pin</b> An nSS pin - this will be lowered before SPI output and raised afterwards (optional). There will be a small delay between when this is lowered and when sending starts, and also between sending finishing and it being raised.</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_SPI_send8bit">function SPI.send8bit</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function SPI.send8bit(data,bit0,bit1,nss_pin)</code></p>
  <h4>Description</h4>
   <p class="description">Send data down SPI, using 8 bits for each 'real' bit (MSB first). This can be useful for faking one-wire style protocols</p>
   <p class="description">Sending multiple bytes in one call to send is preferable as they can then be transmitted end to end. Using multiple calls to send() will result in significantly slower transmission speeds.</p>
  <h4>Parameters</h4>
   <p class="param"><b> data</b> The data to send - either an integer, array, or string</p>
   <p class="param"><b> bit0</b> The 8 bits to send for a 0 (MSB first)</p>
   <p class="param"><b> bit1</b> The 8 bits to send for a 1 (MSB first)</p>
   <p class="param"><b> nss_pin</b> An nSS pin - this will be lowered before SPI output and raised afterwards (optional). There will be a small delay between when this is lowered and when sending starts, and also between sending finishing and it being raised</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_SPI_setup">function SPI.setup</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function SPI.setup(options)</code></p>
  <h4>Description</h4>
   <p class="description">Set up this SPI port as SPI Master, with no checksum</p>
   <p class="description">If not specified in options, the default pins are used (usually the lowest numbered pins on the lowest port that supports this peripheral)</p>
  <h4>Parameters</h4>
   <p class="param"><b> options</b> An optional structure containing extra information on initialising the SPI port<br/>Please note that baud rate is set to the nearest that can be managed - which may be -+ 50%<br/><code>{sck:pin, miso:pin, mosi:pin, baud:integer, mode:integer=0, order:'msb'/'lsb'='msb' }</code><br/>If sck,miso and mosi are left out, they will automatically be chosen. However if one or more is specified then the unspecified pins will not be set up.<br/>You can find out which pins to use by looking at <a href="#boards">your board's reference page</a> and searching for pins with the <code>SPI</code> marker.<br/>The SPI <code>mode</code> is between 0 and 3 - see <a href="http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus#Clock_polarity_and_phase<br/>On">http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus#Clock_polarity_and_phase<br/>On</a> STM32F1-based parts, you cannot mix AF and non-AF pins (SPI pins are usually grouped on the chip - and you can't mix pins from two groups). Espruino will not warn you about this.</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_SPI_write">function SPI.write</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function SPI.write(data,...)</code></p>
  <h4>Description</h4>
   <p class="description">Write a character or array of characters to SPI - without reading the result back</p>
  <h4>Parameters</h4>
   <p class="param"><b> data, ...</b> One or more items to write. May be ints, strings, arrays, or objects of the form <code>{data: ..., count:#}</code>.<br/>If the last argument is a pin, it is taken to be the NSS pin</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
<h2 class="class"><a name="Serial">Serial Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This class allows use of the built-in USARTs</p>
   <p class="description">Methods may be called on the USB, Serial1, Serial2, Serial3, Serial4, Serial5 and Serial6 objects. While different processors provide different numbers of USARTs, you can always rely on at least Serial1 and Serial2</p>
  <h4>Instances</h4>
  <ul>
    <li><p class="instance">LoopbackA</p>
   <p class="description">A loopback serial device. Data sent to LoopbackA comes out of LoopbackB and vice versa</p>
    </li>
    <li><p class="instance">LoopbackB</p>
   <p class="description">A loopback serial device. Data sent to LoopbackA comes out of LoopbackB and vice versa</p>
    </li>
    <li><p class="instance">Serial1</p>
   <p class="description">The first Serial (USART) port</p>
    </li>
    <li><p class="instance">Serial2</p>
   <p class="description">The second Serial (USART) port</p>
    </li>
    <li><p class="instance">Serial3</p>
   <p class="description">The third Serial (USART) port</p>
    </li>
    <li><p class="instance">Serial4</p>
   <p class="description">The fourth Serial (USART) port</p>
    </li>
    <li><p class="instance">Serial5</p>
   <p class="description">The fifth Serial (USART) port</p>
    </li>
    <li><p class="instance">Serial6</p>
   <p class="description">The sixth Serial (USART) port</p>
    </li>
    <li><p class="instance">USB</p>
   <p class="description">The USB Serial port</p>
    </li>
  </ul>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Serial_onData">function Serial.onData(function)</a></li>
    <li><a href="#l_Serial_print">function Serial.print(string)</a></li>
    <li><a href="#l_Serial_println">function Serial.println(string)</a></li>
    <li><a href="#l_Serial_setConsole">function Serial.setConsole()</a></li>
    <li><a href="#l_Serial_setup">function Serial.setup(baudrate,options)</a></li>
    <li><a href="#l_Serial_write">function Serial.write(data,...)</a></li>
  </ul>
  <h3 class="detail"><a name="l_Serial_onData">function Serial.onData</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Serial.onData(function)</code></p>
  <h4>Description</h4>
   <p class="description">When a character is received on this serial port, the function supplied to onData gets called.</p>
   <p class="description">Only one function can ever be supplied, so calling onData(undefined) will stop any function being called</p>
  <h4>Parameters</h4>
   <p class="param"><b> function</b> A function to call when data arrives. It takes one argument, which is an object with a 'data' field</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Serial_print">function Serial.print</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Serial.print(string)</code></p>
  <h4>Description</h4>
   <p class="description">Print a string to the serial port - without a line feed</p>
  <h4>Parameters</h4>
   <p class="param"><b> string</b> A String to print</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Serial_println">function Serial.println</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Serial.println(string)</code></p>
  <h4>Description</h4>
   <p class="description">Print a line to the serial port (newline character sent are '
')</p>
  <h4>Parameters</h4>
   <p class="param"><b> string</b> A String to print</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Serial_setConsole">function Serial.setConsole</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Serial.setConsole()</code></p>
  <h4>Description</h4>
   <p class="description">Set this Serial port as the port for the console</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Serial_setup">function Serial.setup</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Serial.setup(baudrate,options)</code></p>
  <h4>Description</h4>
   <p class="description">Setup this Serial port with the given baud rate and options.</p>
   <p class="description">If not specified in options, the default pins are used (usually the lowest numbered pins on the lowest port that supports this peripheral)</p>
  <h4>Parameters</h4>
   <p class="param"><b> baudrate</b> The baud rate - the default is 9600</p>
   <p class="param"><b> options</b> An optional structure containing extra information on initialising the serial port.<br/><code>{rx:pin,tx:pin,bytesize:8,parity:null/'none'/'o'/'odd'/'e'/'even',stopbits:1}</code><br/>You can find out which pins to use by looking at <a href="#boards">your board's reference page</a> and searching for pins with the <code>UART</code>/<code>USART</code> markers.<br/>Note that even after changing the RX and TX pins, if you have called setup before then the previous RX and TX pins will still be connected to the Serial port as well - until you set them to something else using digitalWrite</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Serial_write">function Serial.write</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Serial.write(data,...)</code></p>
  <h4>Description</h4>
   <p class="description">Write a character or array of characters to the serial port - without a line feed</p>
  <h4>Parameters</h4>
   <p class="param"><b> data, ...</b> One or more items to write. May be ints, strings, arrays, or objects of the form <code>{data: ..., count:#}</code>.</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
<h2 class="class"><a name="String">String Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This is the built-in class for Text Strings.</p>
   <p class="description">Text Strings in Espruino are not zero-terminated, so you can store zeros in them.</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_String_String">constructor String(str)</a></li>
    <li><a href="#l_String_charAt">function String.charAt(pos)</a></li>
    <li><a href="#l_String_charCodeAt">function String.charCodeAt(pos)</a></li>
    <li><a href="#l_String_fromCharCode">String.fromCharCode(code,...)</a></li>
    <li><a href="#l_String_indexOf">function String.indexOf(substring,fromIndex)</a></li>
    <li><a href="#l_String_lastIndexOf">function String.lastIndexOf(substring,fromIndex)</a></li>
    <li><a href="#l_String_length">property String.length</a></li>
    <li><a href="#l_String_replace">function String.replace(subStr,newSubStr)</a></li>
    <li><a href="#l_String_slice">function String.slice(start,end)</a></li>
    <li><a href="#l_String_split">function String.split(separator)</a></li>
    <li><a href="#l_String_substr">function String.substr(start,len)</a></li>
    <li><a href="#l_String_substring">function String.substring(start,end)</a></li>
    <li><a href="#l_String_toLowerCase">function String.toLowerCase()</a></li>
    <li><a href="#l_String_toUpperCase">function String.toUpperCase()</a></li>
  </ul>
  <h3 class="detail"><a name="l_String_String">constructor String</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>constructor String(str)</code></p>
  <h4>Description</h4>
   <p class="description">Create a new String</p>
  <h4>Parameters</h4>
   <p class="param"><b> str</b> A value to turn into a string. If undefined or not supplied, an empty String is created.</p>
  <h4>Returns</h4>
   <p class="return">A String</p>
  <h3 class="detail"><a name="l_String_charAt">function String.charAt</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function String.charAt(pos)</code></p>
  <h4>Description</h4>
   <p class="description">Return a single character at the given position in the String.</p>
  <h4>Parameters</h4>
   <p class="param"><b> pos</b> The character number in the string. Negative values return characters from end of string (-1 = last char)</p>
  <h4>Returns</h4>
   <p class="return">The character in the string</p>
  <h3 class="detail"><a name="l_String_charCodeAt">function String.charCodeAt</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function String.charCodeAt(pos)</code></p>
  <h4>Description</h4>
   <p class="description">Return the integer value of a single character at the given position in the String.</p>
   <p class="description">Note that this returns 0 not 'NaN' for out of bounds characters</p>
  <h4>Parameters</h4>
   <p class="param"><b> pos</b> The character number in the string. Negative values return characters from end of string (-1 = last char)</p>
  <h4>Returns</h4>
   <p class="return">The integer value of a character in the string</p>
  <h3 class="detail"><a name="l_String_fromCharCode">String.fromCharCode</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>String.fromCharCode(code,...)</code></p>
  <h4>Description</h4>
   <p class="description">Return the character(s) represented by the given character code(s).</p>
  <h4>Parameters</h4>
   <p class="param"><b> code, ...</b> One or more character codes to create a string from (range 0-255).</p>
  <h4>Returns</h4>
   <p class="return">The character</p>
  <h3 class="detail"><a name="l_String_indexOf">function String.indexOf</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function String.indexOf(substring,fromIndex)</code></p>
  <h4>Description</h4>
   <p class="description">Return the index of substring in this string, or -1 if not found</p>
  <h4>Parameters</h4>
   <p class="param"><b> substring</b> The string to search for</p>
   <p class="param"><b> fromIndex</b> Index to search from</p>
  <h4>Returns</h4>
   <p class="return">The index of the string, or -1 if not found</p>
  <h3 class="detail"><a name="l_String_lastIndexOf">function String.lastIndexOf</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function String.lastIndexOf(substring,fromIndex)</code></p>
  <h4>Description</h4>
   <p class="description">Return the last index of substring in this string, or -1 if not found</p>
  <h4>Parameters</h4>
   <p class="param"><b> substring</b> The string to search for</p>
   <p class="param"><b> fromIndex</b> Index to search from</p>
  <h4>Returns</h4>
   <p class="return">The index of the string, or -1 if not found</p>
  <h3 class="detail"><a name="l_String_length">property String.length</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>property String.length</code></p>
  <h4>Description</h4>
   <p class="description">Find the length of the string</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The value of the string</p>
  <h3 class="detail"><a name="l_String_replace">function String.replace</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function String.replace(subStr,newSubStr)</code></p>
  <h4>Description</h4>
   <p class="description">Search and replace ONE occurrance of <code>subStr</code> with <code>newSubStr</code> and return the result. This doesn't alter the original string. Regular expressions not supported.</p>
  <h4>Parameters</h4>
   <p class="param"><b> subStr</b> The string to search for</p>
   <p class="param"><b> newSubStr</b> The string to replace it with</p>
  <h4>Returns</h4>
   <p class="return">This string with <code>subStr</code> replaced</p>
  <h3 class="detail"><a name="l_String_slice">function String.slice</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function String.slice(start,end)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> start</b> The start character index, if negative it is from the end of the string</p>
   <p class="param"><b> end</b> The end character index, if negative it is from the end of the string, and if omitted it is the end of the string</p>
  <h4>Returns</h4>
   <p class="return">Part of this string from start for len characters</p>
  <h3 class="detail"><a name="l_String_split">function String.split</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function String.split(separator)</code></p>
  <h4>Description</h4>
   <p class="description">Return an array made by splitting this string up by the separator. eg. <code>'1,2,3'.split(',')==[1,2,3]</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> separator</b> The start character index</p>
  <h4>Returns</h4>
   <p class="return">Part of this string from start for len characters</p>
  <h3 class="detail"><a name="l_String_substr">function String.substr</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function String.substr(start,len)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> start</b> The start character index</p>
   <p class="param"><b> len</b> The number of characters</p>
  <h4>Returns</h4>
   <p class="return">Part of this string from start for len characters</p>
  <h3 class="detail"><a name="l_String_substring">function String.substring</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function String.substring(start,end)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> start</b> The start character index</p>
   <p class="param"><b> end</b> The end character index</p>
  <h4>Returns</h4>
   <p class="return">The part of this string between start and end</p>
  <h3 class="detail"><a name="l_String_toLowerCase">function String.toLowerCase</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function String.toLowerCase()</code></p>
  <h4>Parameters</h4>
  <h4>Returns</h4>
   <p class="return">The lowercase version of this string</p>
  <h3 class="detail"><a name="l_String_toUpperCase">function String.toUpperCase</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function String.toUpperCase()</code></p>
  <h4>Parameters</h4>
  <h4>Returns</h4>
   <p class="return">The uppercase version of this string</p>
<h2 class="class"><a name="Trig">Trig Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This class exists in order to interface Espruino with fast-moving trigger wheels. Trigger wheels are physical discs with evenly spaced teeth cut into them, and often with one or two teeth next to each other missing. A sensor sends a signal whenever a tooth passed by, and this allows a device to measure not only RPM, but absolute position.</p>
   <p class="description">This class is currently in testing - it is NOT AVAILABLE on normal boards.</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Trig_getErrorArray">Trig.getErrorArray()</a></li>
    <li><a href="#l_Trig_getErrors">Trig.getErrors()</a></li>
    <li><a href="#l_Trig_getPosAtTime">Trig.getPosAtTime(time)</a></li>
    <li><a href="#l_Trig_getRPM">Trig.getRPM()</a></li>
    <li><a href="#l_Trig_getTrigger">Trig.getTrigger(num)</a></li>
    <li><a href="#l_Trig_killTrigger">Trig.killTrigger(num)</a></li>
    <li><a href="#l_Trig_setTrigger">Trig.setTrigger(num,pos,pins,pulseLength)</a></li>
    <li><a href="#l_Trig_setup">Trig.setup(pin,options)</a></li>
  </ul>
  <h3 class="detail"><a name="l_Trig_getErrorArray">Trig.getErrorArray</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Trig.getErrorArray()</code></p>
  <h4>Description</h4>
   <p class="description">Get the current error flags from the trigger wheel - and zero them</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">An array of error strings</p>
  <h3 class="detail"><a name="l_Trig_getErrors">Trig.getErrors</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Trig.getErrors()</code></p>
  <h4>Description</h4>
   <p class="description">Get the current error flags from the trigger wheel - and zero them</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The error flags</p>
  <h3 class="detail"><a name="l_Trig_getPosAtTime">Trig.getPosAtTime</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Trig.getPosAtTime(time)</code></p>
  <h4>Description</h4>
   <p class="description">Get the position of the trigger wheel at the given time (from getTime)</p>
  <h4>Parameters</h4>
   <p class="param"><b> time</b> The time at which to find the position</p>
  <h4>Returns</h4>
   <p class="return">The position of the trigger wheel in teeth - as a floating point number</p>
  <h3 class="detail"><a name="l_Trig_getRPM">Trig.getRPM</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Trig.getRPM()</code></p>
  <h4>Description</h4>
   <p class="description">Get the RPM of the trigger wheel</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The current RPM of the trigger wheel</p>
  <h3 class="detail"><a name="l_Trig_getTrigger">Trig.getTrigger</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Trig.getTrigger(num)</code></p>
  <h4>Description</h4>
   <p class="description">Get the current state of a trigger</p>
  <h4>Parameters</h4>
   <p class="param"><b> num</b> The trigger number (0..7)</p>
  <h4>Returns</h4>
   <p class="return">A structure containing all information about the trigger</p>
  <h3 class="detail"><a name="l_Trig_killTrigger">Trig.killTrigger</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Trig.killTrigger(num)</code></p>
  <h4>Description</h4>
   <p class="description">Disable a trigger</p>
  <h4>Parameters</h4>
   <p class="param"><b> num</b> The trigger number (0..7)</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Trig_setTrigger">Trig.setTrigger</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Trig.setTrigger(num,pos,pins,pulseLength)</code></p>
  <h4>Description</h4>
   <p class="description">Set a trigger for a certain point in the cycle</p>
  <h4>Parameters</h4>
   <p class="param"><b> num</b> The trigger number (0..7)</p>
   <p class="param"><b> pos</b> The position (in degrees) to fire the trigger at</p>
   <p class="param"><b> pins</b> An array of pins to pulse (max 4)</p>
   <p class="param"><b> pulseLength</b> The time (in msec) to pulse for</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Trig_setup">Trig.setup</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>Trig.setup(pin,options)</code></p>
  <h4>Description</h4>
   <p class="description">Initialise the trigger class</p>
  <h4>Parameters</h4>
   <p class="param"><b> pin</b> The pin to use for triggering</p>
   <p class="param"><b> options</b> Additional options as an object. defaults are: <code>{teethTotal:60,teethMissing:2,minRPM:30,keyPosition:0}</code></p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
<h2 class="class"><a name="Uint16Array">Uint16Array Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This is the built-in JavaScript class for a typed array.</p>
   <p class="description">Instantiate this in order to efficiently store arrays of data (Espruino's normal arrays store data in a map, which is inefficient for non-sparse arrays). </p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Uint16Array_Uint16Array">constructor Uint16Array(arr,byteOffset,length)</a></li>
  </ul>
  <h3 class="detail"><a name="l_Uint16Array_Uint16Array">constructor Uint16Array</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>constructor Uint16Array(arr,byteOffset,length)</code></p>
  <h4>Description</h4>
   <p class="description">Create a typed array based on the given input. Either an existing Array Buffer, an Integer as a Length, or a simple array. If an ArrayBuffer view (eg. Uint8Array rather than ArrayBuffer) is given, it will be completely copied rather than referenced.</p>
  <h4>Parameters</h4>
   <p class="param"><b> arr</b> The array or typed array to base this off, or an integer which is the array length</p>
   <p class="param"><b> byteOffset</b> The byte offset in the ArrayBuffer  (ONLY IF the first argument was an ArrayBuffer)</p>
   <p class="param"><b> length</b> The length (ONLY IF the first argument was an ArrayBuffer)</p>
  <h4>Returns</h4>
   <p class="return">A typed array</p>
<h2 class="class"><a name="Uint32Array">Uint32Array Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This is the built-in JavaScript class for a typed array.</p>
   <p class="description">Instantiate this in order to efficiently store arrays of data (Espruino's normal arrays store data in a map, which is inefficient for non-sparse arrays). </p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Uint32Array_Uint32Array">constructor Uint32Array(arr,byteOffset,length)</a></li>
  </ul>
  <h3 class="detail"><a name="l_Uint32Array_Uint32Array">constructor Uint32Array</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>constructor Uint32Array(arr,byteOffset,length)</code></p>
  <h4>Description</h4>
   <p class="description">Create a typed array based on the given input. Either an existing Array Buffer, an Integer as a Length, or a simple array. If an ArrayBuffer view (eg. Uint8Array rather than ArrayBuffer) is given, it will be completely copied rather than referenced.</p>
  <h4>Parameters</h4>
   <p class="param"><b> arr</b> The array or typed array to base this off, or an integer which is the array length</p>
   <p class="param"><b> byteOffset</b> The byte offset in the ArrayBuffer  (ONLY IF the first argument was an ArrayBuffer)</p>
   <p class="param"><b> length</b> The length (ONLY IF the first argument was an ArrayBuffer)</p>
  <h4>Returns</h4>
   <p class="return">A typed array</p>
<h2 class="class"><a name="Uint8Array">Uint8Array Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This is the built-in JavaScript class for a typed array.</p>
   <p class="description">Instantiate this in order to efficiently store arrays of data (Espruino's normal arrays store data in a map, which is inefficient for non-sparse arrays). </p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Uint8Array_Uint8Array">constructor Uint8Array(arr,byteOffset,length)</a></li>
  </ul>
  <h3 class="detail"><a name="l_Uint8Array_Uint8Array">constructor Uint8Array</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>constructor Uint8Array(arr,byteOffset,length)</code></p>
  <h4>Description</h4>
   <p class="description">Create a typed array based on the given input. Either an existing Array Buffer, an Integer as a Length, or a simple array. If an ArrayBuffer view (eg. Uint8Array rather than ArrayBuffer) is given, it will be completely copied rather than referenced.</p>
  <h4>Parameters</h4>
   <p class="param"><b> arr</b> The array or typed array to base this off, or an integer which is the array length</p>
   <p class="param"><b> byteOffset</b> The byte offset in the ArrayBuffer  (ONLY IF the first argument was an ArrayBuffer)</p>
   <p class="param"><b> length</b> The length (ONLY IF the first argument was an ArrayBuffer)</p>
  <h4>Returns</h4>
   <p class="return">A typed array</p>
<h2 class="class"><a name="WIZnet">WIZnet Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description"></p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_WIZnet_connect">WIZnet.connect()</a></li>
  </ul>
  <h3 class="detail"><a name="l_WIZnet_connect">WIZnet.connect</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>WIZnet.connect()</code></p>
  <h4>Description</h4>
   <p class="description">Initialise the WIZnet module and return an Ethernet object</p>
  <h4>Parameters</h4>
  <h4>Returns</h4>
   <p class="return">A WLAN Object</p>
<h2 class="class"><a name="WLAN">WLAN Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">An instantiation of a WiFi network adaptor</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_WLAN_connect">function WLAN.connect(ap,key,callback)</a></li>
    <li><a href="#l_WLAN_disconnect">function WLAN.disconnect()</a></li>
    <li><a href="#l_WLAN_getIP">function WLAN.getIP()</a></li>
    <li><a href="#l_WLAN_reconnect">function WLAN.reconnect()</a></li>
    <li><a href="#l_WLAN_setIP">function WLAN.setIP(options)</a></li>
  </ul>
  <h3 class="detail"><a name="l_WLAN_connect">function WLAN.connect</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function WLAN.connect(ap,key,callback)</code></p>
  <h4>Description</h4>
   <p class="description">Connect to a wireless network</p>
  <h4>Parameters</h4>
   <p class="param"><b> ap</b> Access point name</p>
   <p class="param"><b> key</b> WPA2 key (or undefined for unsecured connection)</p>
   <p class="param"><b> callback</b> Function to call back with connection status. It has one argument which is one of 'connect'/'disconnect'/'dhcp'</p>
  <h4>Returns</h4>
   <p class="return">True if connection succeeded, false if it didn't.</p>
  <h3 class="detail"><a name="l_WLAN_disconnect">function WLAN.disconnect</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function WLAN.disconnect()</code></p>
  <h4>Description</h4>
   <p class="description">Completely uninitialise and power down the CC3000. After this you'll have to use <code>require("CC3000").connect()</code> again.</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_WLAN_getIP">function WLAN.getIP</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function WLAN.getIP()</code></p>
  <h4>Description</h4>
   <p class="description">Get the current IP address</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">See description above</p>
  <h3 class="detail"><a name="l_WLAN_reconnect">function WLAN.reconnect</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function WLAN.reconnect()</code></p>
  <h4>Description</h4>
   <p class="description">Completely uninitialise and power down the CC3000, then reconnect to the old access point.</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_WLAN_setIP">function WLAN.setIP</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function WLAN.setIP(options)</code></p>
  <h4>Description</h4>
   <p class="description">Set the current IP address for get an IP from DHCP (if no options object is specified).</p>
   <p class="description">**Note:** Changes are written to non-volatile memory, but will only take effect after calling <code>wlan.reconnect()</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> options</b> Object containing IP address options <code>{ ip : '1,2,3,4', subnet, gateway, dns  }</code>, or do not supply an object in otder to force DHCP.</p>
  <h4>Returns</h4>
   <p class="return">True on success</p>
<h2 class="class"><a name="Waveform">Waveform Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This class handles waveforms. In Espruino, a Waveform is a set of data that you want to input or output.</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_Waveform_Waveform">constructor Waveform(samples,options)</a></li>
    <li><a href="#l_Waveform_startInput">function Waveform.startInput(output,freq,options)</a></li>
    <li><a href="#l_Waveform_startOutput">function Waveform.startOutput(output,freq,options)</a></li>
    <li><a href="#l_Waveform_stop">function Waveform.stop()</a></li>
  </ul>
  <h3 class="detail"><a name="l_Waveform_Waveform">constructor Waveform</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>constructor Waveform(samples,options)</code></p>
  <h4>Description</h4>
   <p class="description">Create a waveform class. This allows high speed input and output of waveforms. It has an internal variable called <code>buffer</code> (as well as <code>buffer2</code> when double-buffered - see <code>options</code> below) which contains the data to input/output.</p>
   <p class="description">When double-buffered, a 'buffer' event will be emitted each time a buffer is finished with (the argument is that buffer). When the recording stops, a 'finish' event will be emitted (with the first argument as the buffer).</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> samples</b> The number of samples</p>
   <p class="param"><b> options</b> Optional options struct <code>{doubleBuffer:bool, bits : 8/16}</code> where: <code>doubleBuffer</code> is whether to allocate two buffers or not (default false), and bits is the amount of bits to use (default 8).</p>
  <h4>Returns</h4>
   <p class="return">An Waveform object</p>
  <h3 class="detail"><a name="l_Waveform_startInput">function Waveform.startInput</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Waveform.startInput(output,freq,options)</code></p>
  <h4>Description</h4>
   <p class="description">Will start inputting the waveform on the given pin that supports analog. If not repeating, it'll emit a <code>finish</code> event when it is done.</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> output</b> The pin to output on</p>
   <p class="param"><b> freq</b> The frequency to output each sample at</p>
   <p class="param"><b> options</b> Optional options struct <code>{time:float,repeat:bool}</code> where: <code>time</code> is the that the waveform with start output at, e.g. <code>getTime()+1</code> (otherwise it is immediate), <code>repeat</code> is a boolean specifying whether to repeat the give sample</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Waveform_startOutput">function Waveform.startOutput</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Waveform.startOutput(output,freq,options)</code></p>
  <h4>Description</h4>
   <p class="description">Will start outputting the waveform on the given pin - the pin must have previously been initialised with <a href="#l__global_analogWrite">analogWrite</a>. If not repeating, it'll emit a <code>finish</code> event when it is done.</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> output</b> The pin to output on</p>
   <p class="param"><b> freq</b> The frequency to output each sample at</p>
   <p class="param"><b> options</b> Optional options struct <code>{time:float,repeat:bool}</code> where: <code>time</code> is the that the waveform with start output at, e.g. <code>getTime()+1</code> (otherwise it is immediate), <code>repeat</code> is a boolean specifying whether to repeat the give sample</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_Waveform_stop">function Waveform.stop</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function Waveform.stop()</code></p>
  <h4>Description</h4>
   <p class="description">Stop a waveform that is currently outputting</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
<h2 class="class"><a name="console">console Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_console_log">console.log(text,...)</a></li>
  </ul>
  <h3 class="detail"><a name="l_console_log">console.log</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>console.log(text,...)</code></p>
  <h4>Description</h4>
   <p class="description">Print the supplied string(s) to the console</p>
   <p class="description">**Note:** If you're connected to a computer (not a wall adaptor) via USB but **you are not running a terminal app** then when you <a href="#l__global_print">print</a> data Espruino may pause execution and wait until the computer requests the data it is trying to <a href="#l__global_print">print</a>.</p>
  <h4>Parameters</h4>
   <p class="param"><b> text, ...</b> One or more arguments to print</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
<h2 class="class"><a name="fs">fs Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This library handles interfacing with a FAT32 filesystem on an SD card. The API is designed to be similar to node.js's - However Espruino does not currently support asynchronous file IO, so the functions behave like node.js's xxxxSync functions. Versions of the functions with 'Sync' after them are also provided for compatibility.</p>
   <p class="description">Currently this provides minimal file IO - it's great for logging and loading/saving settings, but not good for loading large amounts of data as you will soon fill your memory up.</p>
   <p class="description">It is currently only available on boards that contain an SD card slot, such as the Olimexino and the HY. It can not currently be added to boards that did not ship with a card slot.</p>
   <p class="description">To use this, you must type <code>var fs = <a href="#l__global_require">require</a>('fs')</code> to get access to the library</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_fs_appendFile">fs.appendFile(path,data)</a></li>
    <li><a href="#l_fs_appendFileSync">fs.appendFileSync(path,data)</a></li>
    <li><a href="#l_fs_pipe">fs.pipe(source,destination,options)</a></li>
    <li><a href="#l_fs_readFile">fs.readFile(path)</a></li>
    <li><a href="#l_fs_readFileSync">fs.readFileSync(path)</a></li>
    <li><a href="#l_fs_readdir">fs.readdir(path)</a></li>
    <li><a href="#l_fs_readdirSync">fs.readdirSync(path)</a></li>
    <li><a href="#l_fs_unlink">fs.unlink(path)</a></li>
    <li><a href="#l_fs_unlinkSync">fs.unlinkSync(path)</a></li>
    <li><a href="#l_fs_writeFile">fs.writeFile(path,data)</a></li>
    <li><a href="#l_fs_writeFileSync">fs.writeFileSync(path,data)</a></li>
  </ul>
  <h3 class="detail"><a name="l_fs_appendFile">fs.appendFile</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>fs.appendFile(path,data)</code></p>
  <h4>Description</h4>
   <p class="description">Append the data to the given file, created a new file if it doesn't exist</p>
   <p class="description">NOTE: Espruino does not yet support Async file IO, so this function behaves like the 'Sync' version.</p>
  <h4>Parameters</h4>
   <p class="param"><b> path</b> The path of the file to write</p>
   <p class="param"><b> data</b> The data to write to the file</p>
  <h4>Returns</h4>
   <p class="return">True on success, false on failure</p>
  <h3 class="detail"><a name="l_fs_appendFileSync">fs.appendFileSync</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>fs.appendFileSync(path,data)</code></p>
  <h4>Description</h4>
   <p class="description">Append the data to the given file, created a new file if it doesn't exist</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> path</b> The path of the file to write</p>
   <p class="param"><b> data</b> The data to write to the file</p>
  <h4>Returns</h4>
   <p class="return">True on success, false on failure</p>
  <h3 class="detail"><a name="l_fs_pipe">fs.pipe</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>fs.pipe(source,destination,options)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> source</b> The source file/stream that will send content.</p>
   <p class="param"><b> destination</b> The destination file/stream that will receive content from the source.</p>
   <p class="param"><b> options</b> An optional object <code>{ chunkSize : int=64, end : bool=true, complete : function }</code><br/>chunkSize : The amount of data to pipe from source to destination at a time<br/>complete : a function to call when the pipe activity is complete<br/>end : call the 'end' function on the destination when the source is finished</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_fs_readFile">fs.readFile</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>fs.readFile(path)</code></p>
  <h4>Description</h4>
   <p class="description">Read all data from a file and return as a string</p>
   <p class="description">NOTE: Espruino does not yet support Async file IO, so this function behaves like the 'Sync' version.</p>
  <h4>Parameters</h4>
   <p class="param"><b> path</b> The path of the file to read</p>
  <h4>Returns</h4>
   <p class="return">A string containing the contents of the file (or undefined if the file doesn't exist)</p>
  <h3 class="detail"><a name="l_fs_readFileSync">fs.readFileSync</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>fs.readFileSync(path)</code></p>
  <h4>Description</h4>
   <p class="description">Read all data from a file and return as a string.</p>
   <p class="description">**Note:** The size of files you can <a href="#l__global_load">load</a> using this method is limited by the amount of available RAM. To read files a bit at a time, see the <code>File</code> class.</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> path</b> The path of the file to read</p>
  <h4>Returns</h4>
   <p class="return">A string containing the contents of the file (or undefined if the file doesn't exist)</p>
  <h3 class="detail"><a name="l_fs_readdir">fs.readdir</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>fs.readdir(path)</code></p>
  <h4>Description</h4>
   <p class="description">List all files in the supplied directory, returning them as an array of strings.</p>
   <p class="description">NOTE: Espruino does not yet support Async file IO, so this function behaves like the 'Sync' version.</p>
  <h4>Parameters</h4>
   <p class="param"><b> path</b> The path of the directory to list. If it is not supplied, '' is assumed, which will list the root directory</p>
  <h4>Returns</h4>
   <p class="return">An array of filename strings (or undefined if the directory couldn't be listed)</p>
  <h3 class="detail"><a name="l_fs_readdirSync">fs.readdirSync</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>fs.readdirSync(path)</code></p>
  <h4>Description</h4>
   <p class="description">List all files in the supplied directory, returning them as an array of strings.</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> path</b> The path of the directory to list. If it is not supplied, '' is assumed, which will list the root directory</p>
  <h4>Returns</h4>
   <p class="return">An array of filename strings (or undefined if the directory couldn't be listed)</p>
  <h3 class="detail"><a name="l_fs_unlink">fs.unlink</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>fs.unlink(path)</code></p>
  <h4>Description</h4>
   <p class="description">Delete the given file</p>
   <p class="description">NOTE: Espruino does not yet support Async file IO, so this function behaves like the 'Sync' version.</p>
  <h4>Parameters</h4>
   <p class="param"><b> path</b> The path of the file to delete</p>
  <h4>Returns</h4>
   <p class="return">True on success, or false on failure</p>
  <h3 class="detail"><a name="l_fs_unlinkSync">fs.unlinkSync</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>fs.unlinkSync(path)</code></p>
  <h4>Description</h4>
   <p class="description">Delete the given file</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> path</b> The path of the file to delete</p>
  <h4>Returns</h4>
   <p class="return">True on success, or false on failure</p>
  <h3 class="detail"><a name="l_fs_writeFile">fs.writeFile</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>fs.writeFile(path,data)</code></p>
  <h4>Description</h4>
   <p class="description">Write the data to the given file</p>
   <p class="description">NOTE: Espruino does not yet support Async file IO, so this function behaves like the 'Sync' version.</p>
  <h4>Parameters</h4>
   <p class="param"><b> path</b> The path of the file to write</p>
   <p class="param"><b> data</b> The data to write to the file</p>
  <h4>Returns</h4>
   <p class="return">True on success, false on failure</p>
  <h3 class="detail"><a name="l_fs_writeFileSync">fs.writeFileSync</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>fs.writeFileSync(path,data)</code></p>
  <h4>Description</h4>
   <p class="description">Write the data to the given file</p>
   <p class="description"><b>Note:</b> This is only available in some devices: not devices with low flash memory</p>
  <h4>Parameters</h4>
   <p class="param"><b> path</b> The path of the file to write</p>
   <p class="param"><b> data</b> The data to write to the file</p>
  <h4>Returns</h4>
   <p class="return">True on success, false on failure</p>
<h2 class="class"><a name="http">http Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This library allows you to create http servers and make http requests</p>
   <p class="description">In order to use this, you will need an extra module to get network connectivity such as the <a href="/CC3000">TI CC3000</a> or <a href="/WIZnet">WIZnet W5500</a>.</p>
   <p class="description">This is designed to be a cut-down version of the <a href="http://nodejs.org/api/http.html">node.js library</a>. Please see the <a href="/Internet">Internet</a> page for more information on how to use it.</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_http_createServer">http.createServer(callback)</a></li>
    <li><a href="#l_http_get">http.get(options,callback)</a></li>
    <li><a href="#l_http_request">http.request(options,callback)</a></li>
  </ul>
  <h3 class="detail"><a name="l_http_createServer">http.createServer</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>http.createServer(callback)</code></p>
  <h4>Description</h4>
   <p class="description">Create an HTTP Server</p>
   <p class="description">When a request to the server is made, the callback is called. In the callback you can use the methods on the response (httpSRs) to send data. You can also add <code>request.on('data',function() { ... })</code> to listen for POSTed data</p>
  <h4>Parameters</h4>
   <p class="param"><b> callback</b> A function(request,response) that will be called when a connection is made</p>
  <h4>Returns</h4>
   <p class="return">Returns a new httpSrv object</p>
  <h3 class="detail"><a name="l_http_get">http.get</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>http.get(options,callback)</code></p>
  <h4>Description</h4>
   <p class="description">Create an HTTP Request - convenience function for <code>http.request()</code>. <code>options.method</code> is set to 'get', and end is called automatically. See <a href="/Internet">the Internet page</a> for more usage examples.</p>
  <h4>Parameters</h4>
   <p class="param"><b> options</b> An object containing host,port,path,method fields</p>
   <p class="param"><b> callback</b> A function(res) that will be called when a connection is made. You can then call <code>res.on('data', function(data) { ... })</code> and <code>res.on('close', function() { ... })</code> to deal with the response.</p>
  <h4>Returns</h4>
   <p class="return">Returns a new httpCRq object</p>
  <h3 class="detail"><a name="l_http_request">http.request</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>http.request(options,callback)</code></p>
  <h4>Description</h4>
   <p class="description">Create an HTTP Request - end() must be called on it to complete the operation</p>
  <h4>Parameters</h4>
   <p class="param"><b> options</b> An object containing host,port,path,method fields</p>
   <p class="param"><b> callback</b> A function(res) that will be called when a connection is made. You can then call <code>res.on('data', function(data) { ... })</code> and <code>res.on('close', function() { ... })</code> to deal with the response.</p>
  <h4>Returns</h4>
   <p class="return">Returns a new httpCRq object</p>
<h2 class="class"><a name="httpCRq">httpCRq Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">The HTTP client request</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_httpCRq_end">function httpCRq.end(data)</a></li>
    <li><a href="#l_httpCRq_write">function httpCRq.write(data)</a></li>
  </ul>
  <h3 class="detail"><a name="l_httpCRq_end">function httpCRq.end</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function httpCRq.end(data)</code></p>
  <h4>Description</h4>
   <p class="description">Finish this HTTP request - optional data to append as an argument</p>
  <h4>Parameters</h4>
   <p class="param"><b> data</b> A string containing data to send</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_httpCRq_write">function httpCRq.write</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function httpCRq.write(data)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> data</b> A string containing data to send</p>
  <h4>Returns</h4>
   <p class="return">For note compatibility, the boolean false. When the send buffer is empty, a <code>drain</code> event will be sent</p>
<h2 class="class"><a name="httpSRs">httpSRs Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">The HTTP server response</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_httpSRs_end">function httpSRs.end(data)</a></li>
    <li><a href="#l_httpSRs_write">function httpSRs.write(data)</a></li>
    <li><a href="#l_httpSRs_writeHead">function httpSRs.writeHead(statusCode,headers)</a></li>
  </ul>
  <h3 class="detail"><a name="l_httpSRs_end">function httpSRs.end</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function httpSRs.end(data)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> data</b> A string containing data to send</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_httpSRs_write">function httpSRs.write</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function httpSRs.write(data)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> data</b> A string containing data to send</p>
  <h4>Returns</h4>
   <p class="return">For note compatibility, the boolean false. When the send buffer is empty, a <code>drain</code> event will be sent</p>
  <h3 class="detail"><a name="l_httpSRs_writeHead">function httpSRs.writeHead</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function httpSRs.writeHead(statusCode,headers)</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> statusCode</b> The HTTP status code</p>
   <p class="param"><b> headers</b> An object containing the headers</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
<h2 class="class"><a name="httpSrv">httpSrv Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">The HTTP server created by http.createServer</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_httpSrv_close">function httpSrv.close()</a></li>
    <li><a href="#l_httpSrv_listen">function httpSrv.listen(port)</a></li>
  </ul>
  <h3 class="detail"><a name="l_httpSrv_close">function httpSrv.close</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function httpSrv.close()</code></p>
  <h4>Description</h4>
   <p class="description">Stop listening for new HTTP connections</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
  <h3 class="detail"><a name="l_httpSrv_listen">function httpSrv.listen</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>function httpSrv.listen(port)</code></p>
  <h4>Description</h4>
   <p class="description">Start listening for new HTTP connections on the given port</p>
  <h4>Parameters</h4>
   <p class="param"><b> port</b> The port to listen on</p>
  <h4>Returns</h4>
   <p class="return">No return value (undefined)</p>
<h2 class="class"><a name="process">process Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This class contains information about Espruino itself</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_process_env">process.env</a></li>
    <li><a href="#l_process_memory">process.memory()</a></li>
    <li><a href="#l_process_version">process.version</a></li>
  </ul>
  <h3 class="detail"><a name="l_process_env">process.env</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>process.env</code></p>
  <h4>Description</h4>
   <p class="description">Returns an Object containing various pre-defined variables. standard ones are BOARD, VERSION</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">An object</p>
  <h3 class="detail"><a name="l_process_memory">process.memory</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>process.memory()</code></p>
  <h4>Description</h4>
   <p class="description">Run a Garbage Collection pass, and return an object containing information on memory usage.</p>
   <p class="description">free : Memory that is available to be used</p>
   <p class="description">usage : Memory that has been used</p>
   <p class="description">total : Total memory</p>
   <p class="description">history : Memory used for command history - that is freed if memory is low. Note that this is INCLUDED in the figure for 'free'.</p>
   <p class="description">On ARM, stackEndAddress is the address (that can be used with peek/poke/etc) of the END of the stack. The stack grows down, so unless you do a lot of recursion, the bytes above this can be used.</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">Information about memory usage</p>
  <h3 class="detail"><a name="l_process_version">process.version</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>process.version</code></p>
  <h4>Description</h4>
   <p class="description">Returns the version of Espruino as a String</p>
  <h4>Parameters</h4>
   <p class="param">No parameters</p>
  <h4>Returns</h4>
   <p class="return">The version of Espruino</p>
<h2 class="class"><a name="url">url Class</a></h2>
  <p class="top"><a href="#top">(top)</a></p>
   <p class="description">This class helps to convert URLs into Objects of information ready for http.request/get</p>
  <h4>Methods and Fields</h4>
  <ul>
    <li><a href="#l_url_parse">url.parse(urlStr,parseQuery)</a></li>
  </ul>
  <h3 class="detail"><a name="l_url_parse">url.parse</a></h3>
  <p class="top"><a href="#top">(top)</a></p>
  <h4>Call type:</h4>
   <p class="call"><code>url.parse(urlStr,parseQuery)</code></p>
  <h4>Description</h4>
   <p class="description">A utility function to split a URL into parts</p>
   <p class="description">This is useful in web servers for instance when handling a request.</p>
   <p class="description">For instance <code>url.parse("/a?b=c&d=e",true)</code> returns <code>{"method":"GET","host":"","path":"/a?b=c&d=e","pathname":"/a","search":"?b=c&d=e","port":80,"query":{"b":"c","d":"e"}}</code></p>
  <h4>Parameters</h4>
   <p class="param"><b> urlStr</b> A URL to be parsed</p>
   <p class="param"><b> parseQuery</b> Whether to parse the query string into an object not (default = false)</p>
  <h4>Returns</h4>
   <p class="return">An object containing options for <code>http.request</code> or <code>http.get</code>. Contains <code>method</code>, <code>host</code>, <code>path</code>, <code>pathname</code>, <code>search</code>, <code>port</code> and <code>query</code></p>
 </body>
</html>
